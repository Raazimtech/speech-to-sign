<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="description" content="Speech to Sign converts spoken or typed words into sign-language visuals with GIF playback and smart fallback modes.">
  <meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1">
  <meta name="googlebot" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1">
  <meta name="author" content="RT Solutions">
  <meta name="format-detection" content="telephone=no">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Speech to Sign">
  <meta property="og:title" content="Speech to Sign">
  <meta property="og:description" content="Convert speech and text to sign visuals instantly.">
  <meta property="og:url" content="./">
  <meta property="og:locale" content="en_US">
  <meta property="og:image" content="marketing seo image.png">
  <meta property="og:image:alt" content="Speech to Sign marketing banner">
  <meta property="og:image" content="logo (2).png">
  <meta property="og:image:alt" content="Speech to Sign logo">
  <meta property="og:image" content="Gemini_Generated_Image_x0oe4fx0oe4fx0oe.png">
  <meta property="og:image:alt" content="Speech to Sign app icon">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@RTSolutions">
  <meta name="twitter:title" content="Speech to Sign">
  <meta name="twitter:description" content="Convert speech and text to sign visuals instantly.">
  <meta name="twitter:image" content="marketing seo image.png">
  <meta name="twitter:image:alt" content="Speech to Sign marketing banner">
  <meta name="theme-color" content="#0f7f88">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Speech to Sign">
  <link rel="canonical" href="./">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="preload" as="image" href="marketing seo image.png">
  <link rel="preload" as="image" href="logo (2).png">
  <link rel="preload" as="image" href="Gemini_Generated_Image_x0oe4fx0oe4fx0oe.png">
  <link rel="icon" type="image/png" href="Gemini_Generated_Image_x0oe4fx0oe4fx0oe.png">
  <link rel="shortcut icon" href="Gemini_Generated_Image_x0oe4fx0oe4fx0oe.png">
  <link rel="icon" type="image/png" sizes="192x192" href="Gemini_Generated_Image_x0oe4fx0oe4fx0oe.png">
  <link rel="apple-touch-icon" href="Gemini_Generated_Image_x0oe4fx0oe4fx0oe.png">
  <title>Speech to Sign</title>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Speech to Sign",
    "applicationCategory": "EducationalApplication",
    "operatingSystem": "Web",
    "description": "Speech to Sign converts spoken or typed words into sign-language visuals with GIF playback and smart fallback modes.",
    "url": "./",
    "image": [
      "marketing seo image.png",
      "logo (2).png",
      "Gemini_Generated_Image_x0oe4fx0oe4fx0oe.png"
    ],
    "publisher": {
      "@type": "Organization",
      "name": "RT Solutions",
      "logo": {
        "@type": "ImageObject",
        "url": "logo (2).png"
      }
    }
  }
  </script>
  <style>
    :root{--bg:#eef4fb;--card:#fff;--line:#d8e3ef;--ink:#122334;--muted:#506173;--a:#0f7f88;--a2:#0a656c;--bg-grad:linear-gradient(165deg,#f4efe2,#dce9f7 50%,#edf8f1);--soft:#f8fbff;--show-bg:linear-gradient(180deg,#edf6ff,#eefaf7);--show-border:#95aec7;--img-border:#bed1e3;--input-bg:#fff;--chip-bg:#fff;--moon-glow:radial-gradient(circle at 30% 30%,rgba(255,225,150,.55),rgba(255,225,150,.12) 55%,transparent 70%);--moon-crescent:#f9e3a6;--tag-border:rgba(160,130,70,.35);--tag-bg:linear-gradient(135deg,rgba(255,244,208,.88),rgba(223,243,231,.9));--tag-ink:#6a5520}
    *{box-sizing:border-box}html,body{margin:0}
    html{-webkit-text-size-adjust:100%}
    body{font-family:Segoe UI,Tahoma,sans-serif;color:var(--ink);background:var(--bg-grad);overflow-x:hidden}
    body.theme-ramadan-dawn{--bg:#eef4fb;--card:#fff;--line:#d8e3ef;--ink:#122334;--muted:#506173;--a:#0f7f88;--a2:#0a656c;--bg-grad:linear-gradient(165deg,#f4efe2,#dce9f7 50%,#edf8f1);--soft:#f8fbff;--show-bg:linear-gradient(180deg,#edf6ff,#eefaf7);--show-border:#95aec7;--img-border:#bed1e3;--input-bg:#fff;--chip-bg:#fff;--moon-glow:radial-gradient(circle at 30% 30%,rgba(255,225,150,.55),rgba(255,225,150,.12) 55%,transparent 70%);--moon-crescent:#f9e3a6;--tag-border:rgba(160,130,70,.35);--tag-bg:linear-gradient(135deg,rgba(255,244,208,.88),rgba(223,243,231,.9));--tag-ink:#6a5520}
    body.theme-midnight{--bg:#0f1620;--card:#172230;--line:#2d4054;--ink:#e7eef8;--muted:#a9b8c8;--a:#2cb7c1;--a2:#95f1f8;--bg-grad:radial-gradient(1200px 620px at 85% -10%,rgba(255,210,120,.14),transparent 60%),linear-gradient(160deg,#0d1420,#1a2735);--soft:#1c2a3a;--show-bg:linear-gradient(180deg,#1a2a3a,#1a312e);--show-border:#46607a;--img-border:#4f6b87;--input-bg:#1a2735;--chip-bg:#1a2735;--moon-glow:radial-gradient(circle at 30% 30%,rgba(255,215,130,.72),rgba(255,215,130,.16) 55%,transparent 72%);--moon-crescent:#ffe7a8;--tag-border:rgba(240,200,120,.35);--tag-bg:linear-gradient(135deg,rgba(96,78,34,.45),rgba(22,62,57,.5));--tag-ink:#f6ddab}
    body.theme-oasis{--bg:#e9f8f2;--card:#ffffff;--line:#cfe8dd;--ink:#12342d;--muted:#4b6c63;--a:#137a63;--a2:#0d5e4d;--bg-grad:linear-gradient(165deg,#ebfbf5,#d7efe7 50%,#f4fbf8);--soft:#f3fcf8;--show-bg:linear-gradient(180deg,#e9fbf4,#f5fcfa);--show-border:#8fbfad;--img-border:#b6dccc;--input-bg:#fff;--chip-bg:#fff;--moon-glow:radial-gradient(circle at 30% 30%,rgba(201,246,226,.8),rgba(105,198,160,.18) 55%,transparent 75%);--moon-crescent:#b3f0d5;--tag-border:rgba(53,140,112,.3);--tag-bg:linear-gradient(135deg,rgba(210,248,231,.9),rgba(236,252,245,.92));--tag-ink:#1a654f}
    body.theme-sunset{--bg:#fff1e8;--card:#fff9f4;--line:#f2d7c8;--ink:#4a2a24;--muted:#7f5c52;--a:#c05d2d;--a2:#8e3f1f;--bg-grad:linear-gradient(165deg,#fff2e8,#ffe1cf 50%,#ffe9d9);--soft:#fff6ef;--show-bg:linear-gradient(180deg,#fff1e7,#fff7f0);--show-border:#e1b199;--img-border:#efc9b4;--input-bg:#fffaf5;--chip-bg:#fffaf5;--moon-glow:radial-gradient(circle at 30% 30%,rgba(255,196,145,.78),rgba(255,150,102,.2) 55%,transparent 74%);--moon-crescent:#ffd2a6;--tag-border:rgba(191,103,54,.34);--tag-bg:linear-gradient(135deg,rgba(255,229,207,.95),rgba(255,245,234,.96));--tag-ink:#8b4324}
    body.theme-royal{--bg:#f2f1ff;--card:#ffffff;--line:#ddd8ff;--ink:#1f2250;--muted:#5d6293;--a:#4f56c8;--a2:#343ba8;--bg-grad:linear-gradient(165deg,#f2f1ff,#e4e7ff 50%,#edf3ff);--soft:#f7f8ff;--show-bg:linear-gradient(180deg,#eef1ff,#f3f7ff);--show-border:#a2a8e6;--img-border:#c3c8f0;--input-bg:#fff;--chip-bg:#fff;--moon-glow:radial-gradient(circle at 30% 30%,rgba(191,203,255,.78),rgba(123,138,236,.2) 55%,transparent 74%);--moon-crescent:#d7dcff;--tag-border:rgba(97,104,193,.33);--tag-bg:linear-gradient(135deg,rgba(229,232,255,.93),rgba(241,244,255,.95));--tag-ink:#3b429d}
    body.theme-neon-grid{--bg:#080b16;--card:#0e1326;--line:#1e2c4b;--ink:#dff8ff;--muted:#8fb8c8;--a:#00e6b8;--a2:#71ffe2;--bg-grad:linear-gradient(160deg,#070b18,#0b1530 45%,#101d38);--soft:#121b32;--show-bg:linear-gradient(180deg,#10213a,#102d36);--show-border:#2a6d88;--img-border:#2d7390;--input-bg:#0f1a30;--chip-bg:#0f1a30;--moon-glow:radial-gradient(circle at 30% 30%,rgba(122,244,255,.7),rgba(0,255,214,.14) 56%,transparent 74%);--moon-crescent:#8ffff0;--tag-border:rgba(79,244,221,.35);--tag-bg:linear-gradient(135deg,rgba(15,54,64,.7),rgba(7,40,63,.72));--tag-ink:#9dffef}
    body.theme-paper{--bg:#f8f1e4;--card:#fffdf7;--line:#d5c7aa;--ink:#3a2f21;--muted:#705f49;--a:#8a6a32;--a2:#6f5224;--bg-grad:linear-gradient(170deg,#f7efe1,#efe4cd 60%,#f8f1e3);--soft:#fefaf0;--show-bg:linear-gradient(180deg,#f7eddc,#fbf6ea);--show-border:#bea67a;--img-border:#cfba95;--input-bg:#fffdf8;--chip-bg:#fffef9;--moon-glow:radial-gradient(circle at 30% 30%,rgba(232,202,148,.68),rgba(173,132,60,.16) 54%,transparent 75%);--moon-crescent:#e9cf9e;--tag-border:rgba(134,104,56,.33);--tag-bg:linear-gradient(135deg,rgba(252,242,221,.93),rgba(247,235,208,.93));--tag-ink:#6f5424}
    body.theme-mono{--bg:#ececec;--card:#ffffff;--line:#cfcfcf;--ink:#1f1f1f;--muted:#5e5e5e;--a:#2f2f2f;--a2:#111;--bg-grad:linear-gradient(160deg,#f4f4f4,#e3e3e3 55%,#f2f2f2);--soft:#fafafa;--show-bg:linear-gradient(180deg,#f2f2f2,#f7f7f7);--show-border:#a7a7a7;--img-border:#bfbfbf;--input-bg:#fff;--chip-bg:#fff;--moon-glow:radial-gradient(circle at 30% 30%,rgba(170,170,170,.5),rgba(102,102,102,.12) 56%,transparent 74%);--moon-crescent:#cfcfcf;--tag-border:rgba(104,104,104,.33);--tag-bg:linear-gradient(135deg,rgba(238,238,238,.95),rgba(246,246,246,.95));--tag-ink:#444}
    body.theme-forest-noir{--bg:#0b1712;--card:#13221a;--line:#2b4337;--ink:#d8f0e1;--muted:#8db29d;--a:#4cb980;--a2:#9df5c5;--bg-grad:linear-gradient(165deg,#0a1711,#11251b 48%,#143329);--soft:#182b22;--show-bg:linear-gradient(180deg,#163225,#133127);--show-border:#3f7e66;--img-border:#4d8a74;--input-bg:#13261e;--chip-bg:#13261e;--moon-glow:radial-gradient(circle at 30% 30%,rgba(179,255,215,.66),rgba(74,190,132,.14) 56%,transparent 74%);--moon-crescent:#c7ffe1;--tag-border:rgba(117,216,169,.34);--tag-bg:linear-gradient(135deg,rgba(26,72,51,.65),rgba(18,53,40,.68));--tag-ink:#cbffe7}
    body.theme-candy-pop{--bg:#fff0f8;--card:#ffffff;--line:#f5bfd8;--ink:#5d2450;--muted:#8f4d7d;--a:#ff4ea1;--a2:#d42f7f;--bg-grad:linear-gradient(165deg,#ffeefd,#ffd7ec 52%,#ffe8f5);--soft:#fff4fa;--show-bg:linear-gradient(180deg,#ffeef8,#fff6fb);--show-border:#ee9ec7;--img-border:#f5b9d9;--input-bg:#fff;--chip-bg:#fff;--moon-glow:radial-gradient(circle at 30% 30%,rgba(255,174,218,.74),rgba(255,97,187,.16) 55%,transparent 74%);--moon-crescent:#ffc4e6;--tag-border:rgba(226,81,158,.35);--tag-bg:linear-gradient(135deg,rgba(255,225,242,.95),rgba(255,241,249,.95));--tag-ink:#a32069}
    .splash{position:fixed;inset:0;z-index:3000;background:#fff;display:grid;place-items:center;padding:20px;opacity:1;visibility:visible;transition:opacity .3s ease,visibility .3s ease}
    .splash img{width:min(980px,92vw);max-height:88vh;object-fit:contain}
    .splash.hide{opacity:0;visibility:hidden}
    .page{min-height:100vh;padding:clamp(8px,2.5vw,20px);display:flex;align-items:center;justify-content:center}
    .card{width:min(1020px,100%);background:var(--card);border:1px solid var(--line);border-radius:18px;box-shadow:0 20px 40px rgba(18,35,52,.14);padding:clamp(12px,2.2vw,22px)}
    .head{text-align:center;margin-bottom:12px;position:relative}.head h1{margin:0 0 4px;font-size:clamp(1.35rem,4.8vw,2rem)}.head p{margin:0;color:var(--muted)}
    .head::before{content:"";position:absolute;right:8%;top:-16px;width:58px;height:58px;border-radius:50%;background:var(--moon-glow);pointer-events:none}
    .head::after{content:"";position:absolute;right:10%;top:-2px;width:24px;height:24px;border-radius:50%;background:radial-gradient(circle at 70% 50%,transparent 49%,var(--moon-crescent) 51% 66%,transparent 68%);pointer-events:none}
    .ramadanTag{display:inline-block;margin:8px auto 0;padding:6px 12px;border-radius:999px;border:1px solid var(--tag-border);background:var(--tag-bg);color:var(--tag-ink);font-size:.74rem;font-weight:700;letter-spacing:.08em;text-transform:uppercase}
    .siteNav{display:flex;justify-content:center;gap:8px;flex-wrap:wrap;margin:10px 0 4px}
    .siteNav button{display:inline-block;min-height:36px;padding:8px 14px;border:1px solid var(--line);border-radius:999px;background:var(--soft);color:var(--ink);text-decoration:none;font-weight:700;line-height:20px;cursor:pointer}
    .siteNav button.active{border-color:var(--a);background:rgba(44,183,193,.16);color:var(--a2)}
    .reloadTop{position:absolute;left:0;top:0;min-height:36px;padding:0 14px;border-radius:10px;border:1px solid var(--line);background:var(--soft);color:var(--ink);font-weight:700;cursor:pointer}
    .modePane[hidden]{display:none!important}
    .camBox{display:grid;grid-template-columns:1fr;gap:10px}
    .camWrap{position:relative;border:1px dashed var(--show-border);border-radius:12px;background:var(--show-bg);overflow:hidden;min-height:220px}
    #cameraFeed,#cameraOverlay{width:100%;height:auto;display:block;transform:scaleX(-1)}
    #cameraFeed{background:#0f1620;min-height:220px;object-fit:cover}
    #cameraOverlay{position:absolute;left:0;top:0;pointer-events:none}
    .gestureRow{display:grid;grid-template-columns:1fr;gap:8px}
    .gestureWord{min-height:58px;padding:12px;border:1px solid var(--line);border-radius:10px;background:var(--input-bg);font-size:1.05rem;font-weight:700;word-break:break-word}
    .gestureHint{margin:0;color:var(--muted);font-size:.92rem}
    .topToggles{display:flex;align-items:center;justify-content:center;gap:10px;margin:8px 0 12px;flex-wrap:wrap}
    .langTop{display:flex;justify-content:center}
    .langToggleWrap{position:relative}
    .langToggleBtn{min-height:38px;border:1px solid var(--line);background:var(--soft);color:var(--ink);border-radius:10px;padding:0 12px;font-weight:700;cursor:pointer}
    .langPanel{position:absolute;left:0;bottom:calc(100% + 6px);z-index:40;width:min(320px,80vw);background:var(--card);border:1px solid var(--line);border-radius:12px;padding:8px;box-shadow:0 12px 24px rgba(18,35,52,.16)}
    .langPanel select{min-height:40px;max-height:42vh;overflow:auto}
    .themePick{display:flex;align-items:center;gap:8px;background:var(--soft);border:1px solid var(--line);border-radius:12px;padding:6px 8px}
    .themePick label{font-size:.72rem;font-weight:700;letter-spacing:.04em;text-transform:uppercase;color:var(--muted)}
    .themePick select{min-height:34px;border-radius:9px;padding:6px 28px 6px 10px;font-size:.9rem}
    .logo{width:clamp(64px,12vw,90px);height:auto;display:block;margin:0 auto 8px}
    .controls{display:grid;place-items:center;gap:8px;margin-bottom:12px}
    .mic{width:80px;height:80px;border-radius:50%;border:none;background:linear-gradient(145deg,#4facfe,#00f2fe);box-shadow:0 10px 20px rgba(74,144,226,.3);display:grid;place-items:center;cursor:pointer;transition:.3s}
    .mic:hover{transform:scale(1.05);box-shadow:0 15px 25px rgba(74,144,226,.4)}.mic.listening{animation:pulse 1.5s infinite}.mic svg{width:32px;height:32px;fill:#fff}
    .status{min-height:20px;font-weight:700;color:var(--muted)}.status.listening{color:var(--a2)}.status.processing{color:#8a5a00}.status.error{color:#b43f34}
    .settings{display:grid;grid-template-columns:1fr;gap:8px;margin-bottom:12px}
    .set{background:var(--soft);border:1px solid var(--line);border-radius:12px;padding:10px}.set label{display:block;font-size:.78rem;font-weight:700;letter-spacing:.04em;text-transform:uppercase;color:var(--muted);margin-bottom:8px}
    .tog{display:grid;grid-template-columns:1fr 1fr;gap:8px}.tog button{min-height:40px;border-radius:10px;border:1px solid var(--line);background:var(--chip-bg);color:var(--ink);font-weight:700;cursor:pointer;padding:0 8px;white-space:nowrap}.tog button.on{border-color:var(--a);background:rgba(44,183,193,.18);color:var(--a2)}
    .manual{margin-bottom:12px}.manual label{display:block;font-weight:700;margin-bottom:8px}.row{display:grid;grid-template-columns:1fr;gap:8px}
    input,select{width:100%;min-height:46px;border:1px solid var(--line);border-radius:10px;padding:10px 12px;font-size:1rem;background:var(--input-bg);color:var(--ink)}
    .btn{width:100%;min-height:46px;border:none;border-radius:10px;background:var(--a);color:#fff;font-weight:700;padding:0 16px;cursor:pointer}
    .out{display:grid;grid-template-columns:1fr;gap:10px}.blk{background:var(--soft);border:1px solid var(--line);border-radius:12px;padding:12px}.blk h2{margin:0 0 8px;font-size:1rem}
    .blkHead{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px}
    .blkHead h2{margin:0}
    .iconBtn{width:36px;height:36px;border:1px solid var(--line);border-radius:10px;background:var(--chip-bg);color:var(--ink);display:grid;place-items:center;cursor:pointer}
    .iconBtn svg{width:18px;height:18px;fill:currentColor}
    .iconBtn:disabled{opacity:.5;cursor:not-allowed}
    .trans{min-height:28px;overflow-wrap:anywhere}.show{min-height:clamp(150px,30vw,220px);border:1px dashed var(--show-border);border-radius:12px;background:var(--show-bg);display:flex;align-items:center;justify-content:center;padding:12px;text-align:center}
    .show img{width:min(340px,100%);max-height:220px;border-radius:10px;border:1px solid var(--img-border);background:var(--chip-bg);box-shadow:0 10px 20px rgba(20,36,51,.16)}
    .tok{margin-top:8px;min-height:21px;color:var(--muted);font-weight:700}.ph{color:var(--muted)}
    .tcard{min-width:140px;min-height:110px;border:1px solid var(--img-border);border-radius:10px;background:var(--chip-bg);display:grid;place-items:center;padding:10px}
    .tcard b{font-size:.8rem;color:var(--muted);display:block}.tcard span{font-weight:700;color:var(--a2);text-transform:uppercase;word-break:break-word}
    .act{margin-top:12px;display:flex;justify-content:center;gap:10px;flex-wrap:wrap}.clear{width:100%;max-width:240px;min-height:44px;border-radius:12px;border:2px solid var(--a);background:#fff;color:var(--a2);font-weight:700;cursor:pointer}
    .footer{padding:0 clamp(8px,2vw,14px) clamp(10px,2vw,14px)}.credit{margin:auto;max-width:1020px;padding:1rem;border-top:1px solid rgba(20,36,51,.12);text-align:center;background:linear-gradient(135deg,rgba(15,127,136,.15),rgba(255,225,170,.45));border-radius:14px}
    .credit a{text-decoration:none;color:inherit;display:inline-block}.credit p{margin:0 0 6px;font-size:.72rem;letter-spacing:2.2px;text-transform:uppercase;opacity:.65}.credit strong{display:inline-block;padding:.38rem .9rem;border-radius:999px;border:1px solid rgba(20,36,51,.25)}
    body.theme-neon-grid{font-family:"Trebuchet MS",Verdana,sans-serif}
    body.theme-neon-grid .card{border-radius:8px;box-shadow:0 0 0 1px rgba(0,255,214,.15),0 0 34px rgba(0,255,214,.1)}
    body.theme-neon-grid .mic{background:linear-gradient(145deg,#00d7ff,#00ff9f);box-shadow:0 0 0 1px rgba(0,255,214,.4),0 12px 26px rgba(0,255,214,.25)}
    body.theme-neon-grid .blk{border-style:dashed}
    body.theme-paper{font-family:Georgia,"Times New Roman",serif}
    body.theme-paper .card{border-radius:24px;border-width:2px;box-shadow:0 6px 0 rgba(140,113,66,.18)}
    body.theme-paper .blk{border-style:dotted}
    body.theme-paper .btn{border-radius:2px}
    body.theme-mono{font-family:"Segoe UI",Tahoma,sans-serif}
    body.theme-mono .card{border-radius:6px;box-shadow:0 8px 22px rgba(30,30,30,.12)}
    body.theme-mono .mic{background:linear-gradient(145deg,#5a5a5a,#2f2f2f)}
    body.theme-forest-noir{font-family:"Palatino Linotype","Book Antiqua",serif}
    body.theme-forest-noir .card{border-radius:20px;box-shadow:0 24px 44px rgba(0,0,0,.28)}
    body.theme-forest-noir .btn{background:linear-gradient(135deg,#3ea76f,#2f7a53)}
    body.theme-candy-pop{font-family:"Verdana","Trebuchet MS",sans-serif}
    body.theme-candy-pop .card{border-radius:28px;box-shadow:0 20px 42px rgba(255,78,161,.18)}
    body.theme-candy-pop .mic{background:linear-gradient(145deg,#ff7cc1,#ff4ea1)}
    body.theme-candy-pop .btn{background:linear-gradient(135deg,#ff63af,#ff3f97)}
    .fade{animation:fin .22s ease}
    @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(0,242,254,.7)}70%{box-shadow:0 0 0 20px rgba(0,242,254,0)}100%{box-shadow:0 0 0 0 rgba(0,242,254,0)}}
    @keyframes fin{from{opacity:0;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}
    @media(min-width:720px){.settings{grid-template-columns:1fr 1fr}.row{grid-template-columns:1fr auto}.btn{width:auto;min-width:170px}}
    @media(max-width:720px){
      .langPanel{
        top:calc(100% + 6px);
        bottom:auto;
      }
      .head::before{
        right:4px;
        top:-10px;
        width:42px;
        height:42px;
      }
      .head::after{
        right:10px;
        top:-1px;
        width:18px;
        height:18px;
      }
      #signBlock{
        position:sticky;
        top:8px;
        z-index:20;
        border-color:#b8ccdf;
        box-shadow:0 10px 22px rgba(18,35,52,.12);
      }
      #signBlock h2{
        margin-bottom:6px;
      }
      #signBlock .show{
        min-height:140px;
      }
      #signBlock .show img{
        max-height:145px;
      }
      .act{
        gap:8px;
      }
      .act .clear{
        width:calc(50% - 4px);
        max-width:none;
      }
    }
    @media(max-width:420px){.page{padding:8px}.card{border-radius:14px}.head h1{font-size:1.25rem}.head p{font-size:.9rem}.show img{max-height:160px}.credit strong{font-size:.88rem;padding:.34rem .8rem}.head::before{right:2px;top:-8px;width:34px;height:34px}.head::after{right:7px;top:0;width:14px;height:14px}}
    @media(min-width:1200px){.card{padding:24px}}
  </style>
</head>
<body class="theme-ramadan-dawn">
  <div id="entrySplash" class="splash" aria-hidden="true"><img src="marketing seo image.png" alt="Speech to Sign marketing"></div>
  <main class="page">
    <section class="card">
      <header class="head">
        <button id="reload" class="reloadTop" type="button">Reload</button>
        <img class="logo" src="logo (2).png" alt="Speech to Sign logo">
        <h1 id="appTitle">Speech to Sign</h1>
        <p id="appSubtitle">Speak and see it in sign language</p>
        <p id="ramadanTag" class="ramadanTag">Ramadan Kareem</p>
        <nav class="siteNav" aria-label="Main navigation">
          <button id="navSpeechToSign" class="active" type="button">Speech to Sign</button>
          <button id="navSignToSpeech" type="button">Sign to Speech</button>
        </nav>
        <div class="topToggles">
          <div class="langTop" role="group" aria-label="Language toggle">
            <div class="langToggleWrap">
              <button id="langToggleBtn" class="langToggleBtn" type="button" aria-haspopup="listbox" aria-expanded="false" aria-controls="langMenu">Lang: English (US)</button>
              <div id="langMenu" class="langPanel" hidden>
                <select id="langSel" aria-label="Choose language"></select>
              </div>
            </div>
          </div>
          <div class="themePick">
            <label id="themeLabel" for="themeSel">Theme</label>
            <select id="themeSel" aria-label="Choose visual theme">
              <option value="ramadan-dawn">Ramadan Dawn</option>
              <option value="midnight">Midnight</option>
              <option value="oasis">Oasis</option>
              <option value="sunset">Sunset</option>
              <option value="royal">Royal</option>
              <option value="neon-grid">Neon Grid</option>
              <option value="paper">Paper</option>
              <option value="mono">Mono</option>
              <option value="forest-noir">Forest Noir</option>
              <option value="candy-pop">Candy Pop</option>
            </select>
          </div>
        </div>
      </header>
      <div id="speechToSignPane" class="modePane">
      <section class="controls">
        <button id="micBtn" class="mic" aria-label="Start speech recognition">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
        </button>
        <p id="status" class="status">Idle</p>
      </section>
      <section class="out">
        <div id="textBlock" class="blk"><h2 id="recognizedTitle">Recognized Text</h2><p id="trans" class="trans">Click the microphone and start speaking.</p></div>
        <div id="signBlock" class="blk">
          <div class="blkHead">
            <h2 id="signPlaybackTitle">Sign Playback</h2>
            <button id="repeatBtn" class="iconBtn" type="button" aria-label="Repeat sign playback" title="Repeat sign playback" disabled>
              <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M17 1l4 4-4 4V6H8a3 3 0 0 0-3 3v1H3V9a5 5 0 0 1 5-5h9V1zM7 23l-4-4 4-4v3h9a3 3 0 0 0 3-3v-1h2v1a5 5 0 0 1-5 5H7v3z"/></svg>
            </button>
          </div>
          <div id="show" class="show"><p class="ph">Signs will appear here one by one.</p></div>
          <p id="tok" class="tok"></p>
        </div>
      </section>
      <section class="settings">
        <div class="set"><label id="outputLabel">Output</label><div class="tog"><button id="gifBtn" class="on">GIFs</button><button id="textBtn">Text</button></div></div>
        <div class="set"><label id="fallbackLabel">Fallback</label><div class="tog"><button id="smartBtn" class="on">Smart</button><button id="alphaBtn">Alphabet</button></div></div>
      </section>
      <section class="manual"><label id="manualLabel" for="input">Type text to translate</label><div class="row"><input id="input" placeholder="Example: hello, i love you"><button id="translate" class="btn">Translate Text</button></div></section>
      <section class="act"><button id="clear" class="clear">Clear</button></section>
      </div>
      <div id="signToSpeechPane" class="modePane" hidden>
        <section class="out">
          <div class="blk">
            <h2>Live Hand Tracking</h2>
            <div class="camBox">
              <div class="camWrap">
                <video id="cameraFeed" playsinline muted></video>
                <canvas id="cameraOverlay"></canvas>
              </div>
              <p id="gestureStatus" class="status">Camera is off.</p>
            </div>
          </div>
          <div class="blk">
            <h2>Word Builder</h2>
            <div class="gestureRow">
              <div id="gestureWord" class="gestureWord"></div>
              <p class="gestureHint">ASL detector: A-Z, 0-10, plus combined signs (WELCOME, PEACE, BOOK, EXCELLENT). Hold each sign steady.</p>
            </div>
          </div>
        </section>
        <section class="act">
          <button id="startCamBtn" class="clear" type="button">Start Camera</button>
          <button id="speakGestureBtn" class="clear" type="button">Speak</button>
          <button id="clearGestureBtn" class="clear" type="button">Clear</button>
        </section>
      </div>
    </section>
  </main>
  <footer class="footer"><div class="credit"><a href="https://raazimtech.github.io/Raazim-tech/" target="_blank" rel="noopener"><p id="madeByLabel">Made By</p><strong>RT Solutions</strong></a></div></footer>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script>
  (() => {
    const el = {
      mic: document.getElementById("micBtn"), status: document.getElementById("status"), input: document.getElementById("input"),
      translate: document.getElementById("translate"), trans: document.getElementById("trans"), show: document.getElementById("show"),
      tok: document.getElementById("tok"), clear: document.getElementById("clear"), reload: document.getElementById("reload"), gifBtn: document.getElementById("gifBtn"),
      textBtn: document.getElementById("textBtn"), smartBtn: document.getElementById("smartBtn"), alphaBtn: document.getElementById("alphaBtn"),
      langSel: document.getElementById("langSel"), langToggleBtn: document.getElementById("langToggleBtn"), langMenu: document.getElementById("langMenu"),
      themeSel: document.getElementById("themeSel"), repeatBtn: document.getElementById("repeatBtn"),
      navSpeechToSign: document.getElementById("navSpeechToSign"), navSignToSpeech: document.getElementById("navSignToSpeech"),
      speechToSignPane: document.getElementById("speechToSignPane"), signToSpeechPane: document.getElementById("signToSpeechPane"),
      cameraFeed: document.getElementById("cameraFeed"), cameraOverlay: document.getElementById("cameraOverlay"),
      gestureStatus: document.getElementById("gestureStatus"), gestureWord: document.getElementById("gestureWord"),
      startCamBtn: document.getElementById("startCamBtn"), speakGestureBtn: document.getElementById("speakGestureBtn"), clearGestureBtn: document.getElementById("clearGestureBtn"),
      appTitle: document.getElementById("appTitle"), appSubtitle: document.getElementById("appSubtitle"), ramadanTag: document.getElementById("ramadanTag"),
      recognizedTitle: document.getElementById("recognizedTitle"), signPlaybackTitle: document.getElementById("signPlaybackTitle"),
      outputLabel: document.getElementById("outputLabel"), fallbackLabel: document.getElementById("fallbackLabel"), manualLabel: document.getElementById("manualLabel"),
      themeLabel: document.getElementById("themeLabel"), madeByLabel: document.getElementById("madeByLabel")
    };

    const LANGUAGES = [
      { code: "en-US", label: "English (US)" },
      { code: "en-GB", label: "English (UK)" },
      { code: "so-SO", label: "Somali" },
      { code: "af-ZA", label: "Afrikaans" },
      { code: "am-ET", label: "Amharic" },
      { code: "ar-AE", label: "Arabic (UAE)" },
      { code: "ar-BH", label: "Arabic (Bahrain)" },
      { code: "ar-DZ", label: "Arabic (Algeria)" },
      { code: "ar-EG", label: "Arabic (Egypt)" },
      { code: "ar-IQ", label: "Arabic (Iraq)" },
      { code: "ar-JO", label: "Arabic (Jordan)" },
      { code: "ar-KW", label: "Arabic (Kuwait)" },
      { code: "ar-LB", label: "Arabic (Lebanon)" },
      { code: "ar-MA", label: "Arabic (Morocco)" },
      { code: "ar-OM", label: "Arabic (Oman)" },
      { code: "ar-QA", label: "Arabic (Qatar)" },
      { code: "ar-SA", label: "Arabic (Saudi Arabia)" },
      { code: "ar-TN", label: "Arabic (Tunisia)" },
      { code: "ar-YE", label: "Arabic (Yemen)" },
      { code: "az-AZ", label: "Azerbaijani" },
      { code: "bg-BG", label: "Bulgarian" },
      { code: "bn-BD", label: "Bengali (Bangladesh)" },
      { code: "bn-IN", label: "Bengali (India)" },
      { code: "bs-BA", label: "Bosnian" },
      { code: "ca-ES", label: "Catalan" },
      { code: "cs-CZ", label: "Czech" },
      { code: "cy-GB", label: "Welsh" },
      { code: "da-DK", label: "Danish" },
      { code: "de-DE", label: "German (Germany)" },
      { code: "de-AT", label: "German (Austria)" },
      { code: "de-CH", label: "German (Switzerland)" },
      { code: "el-GR", label: "Greek" },
      { code: "en-AU", label: "English (Australia)" },
      { code: "en-CA", label: "English (Canada)" },
      { code: "en-GH", label: "English (Ghana)" },
      { code: "en-IE", label: "English (Ireland)" },
      { code: "en-IN", label: "English (India)" },
      { code: "en-KE", label: "English (Kenya)" },
      { code: "en-NG", label: "English (Nigeria)" },
      { code: "en-NZ", label: "English (New Zealand)" },
      { code: "en-PH", label: "English (Philippines)" },
      { code: "en-TZ", label: "English (Tanzania)" },
      { code: "en-ZA", label: "English (South Africa)" },
      { code: "es-AR", label: "Spanish (Argentina)" },
      { code: "es-BO", label: "Spanish (Bolivia)" },
      { code: "es-CL", label: "Spanish (Chile)" },
      { code: "es-CO", label: "Spanish (Colombia)" },
      { code: "es-CR", label: "Spanish (Costa Rica)" },
      { code: "es-DO", label: "Spanish (Dominican Rep.)" },
      { code: "es-EC", label: "Spanish (Ecuador)" },
      { code: "es-ES", label: "Spanish (Spain)" },
      { code: "es-GT", label: "Spanish (Guatemala)" },
      { code: "es-HN", label: "Spanish (Honduras)" },
      { code: "es-MX", label: "Spanish (Mexico)" },
      { code: "es-NI", label: "Spanish (Nicaragua)" },
      { code: "es-PA", label: "Spanish (Panama)" },
      { code: "es-PE", label: "Spanish (Peru)" },
      { code: "es-PR", label: "Spanish (Puerto Rico)" },
      { code: "es-PY", label: "Spanish (Paraguay)" },
      { code: "es-SV", label: "Spanish (El Salvador)" },
      { code: "es-US", label: "Spanish (US)" },
      { code: "es-UY", label: "Spanish (Uruguay)" },
      { code: "es-VE", label: "Spanish (Venezuela)" },
      { code: "et-EE", label: "Estonian" },
      { code: "eu-ES", label: "Basque" },
      { code: "fa-IR", label: "Persian" },
      { code: "fi-FI", label: "Finnish" },
      { code: "fil-PH", label: "Filipino" },
      { code: "fr-BE", label: "French (Belgium)" },
      { code: "fr-CA", label: "French (Canada)" },
      { code: "fr-CH", label: "French (Switzerland)" },
      { code: "fr-FR", label: "French (France)" },
      { code: "ga-IE", label: "Irish" },
      { code: "gl-ES", label: "Galician" },
      { code: "gu-IN", label: "Gujarati" },
      { code: "he-IL", label: "Hebrew" },
      { code: "hi-IN", label: "Hindi" },
      { code: "hr-HR", label: "Croatian" },
      { code: "hu-HU", label: "Hungarian" },
      { code: "hy-AM", label: "Armenian" },
      { code: "id-ID", label: "Indonesian" },
      { code: "is-IS", label: "Icelandic" },
      { code: "it-CH", label: "Italian (Switzerland)" },
      { code: "it-IT", label: "Italian (Italy)" },
      { code: "ja-JP", label: "Japanese" },
      { code: "jv-ID", label: "Javanese" },
      { code: "ka-GE", label: "Georgian" },
      { code: "kk-KZ", label: "Kazakh" },
      { code: "km-KH", label: "Khmer" },
      { code: "kn-IN", label: "Kannada" },
      { code: "ko-KR", label: "Korean" },
      { code: "lo-LA", label: "Lao" },
      { code: "lt-LT", label: "Lithuanian" },
      { code: "lv-LV", label: "Latvian" },
      { code: "mk-MK", label: "Macedonian" },
      { code: "ml-IN", label: "Malayalam" },
      { code: "mn-MN", label: "Mongolian" },
      { code: "mr-IN", label: "Marathi" },
      { code: "ms-MY", label: "Malay" },
      { code: "my-MM", label: "Burmese" },
      { code: "ne-NP", label: "Nepali" },
      { code: "nl-BE", label: "Dutch (Belgium)" },
      { code: "nl-NL", label: "Dutch (Netherlands)" },
      { code: "no-NO", label: "Norwegian" },
      { code: "pa-IN", label: "Punjabi" },
      { code: "pl-PL", label: "Polish" },
      { code: "pt-BR", label: "Portuguese (Brazil)" },
      { code: "pt-PT", label: "Portuguese (Portugal)" },
      { code: "ro-RO", label: "Romanian" },
      { code: "ru-RU", label: "Russian" },
      { code: "si-LK", label: "Sinhala" },
      { code: "sk-SK", label: "Slovak" },
      { code: "sl-SI", label: "Slovenian" },
      { code: "sq-AL", label: "Albanian" },
      { code: "sr-RS", label: "Serbian" },
      { code: "su-ID", label: "Sundanese" },
      { code: "sv-SE", label: "Swedish" },
      { code: "sw-KE", label: "Swahili (Kenya)" },
      { code: "sw-TZ", label: "Swahili (Tanzania)" },
      { code: "ta-IN", label: "Tamil (India)" },
      { code: "ta-LK", label: "Tamil (Sri Lanka)" },
      { code: "ta-MY", label: "Tamil (Malaysia)" },
      { code: "ta-SG", label: "Tamil (Singapore)" },
      { code: "te-IN", label: "Telugu" },
      { code: "th-TH", label: "Thai" },
      { code: "tr-TR", label: "Turkish" },
      { code: "uk-UA", label: "Ukrainian" },
      { code: "ur-IN", label: "Urdu (India)" },
      { code: "ur-PK", label: "Urdu (Pakistan)" },
      { code: "uz-UZ", label: "Uzbek" },
      { code: "vi-VN", label: "Vietnamese" },
      { code: "zh-CN", label: "Chinese (Mainland)" },
      { code: "zh-HK", label: "Chinese (Hong Kong)" },
      { code: "zh-TW", label: "Chinese (Taiwan)" },
      { code: "zu-ZA", label: "Zulu" }
    ];

    const SIGN_FILES = [
      "100.gif","1000.gif","all.gif","allergic.gif","always.gif","americansignlanguage hello GIF.gif","baby.gif","bad.gif","book.gif","brother  sister.gif",
      "brother.gif","busy.gif","cannot.gif","child.gif","come.gif","continue.gif","cool.gif","death.gif","dont understand.gif","don't understand.gif",
      "each.gif","excuse me.gif","family.gif","fast.gif","father.gif","favourite.gif","fine.gif","free.gif","friend.gif","give.gif","good.gif","gorilla.gif",
      "Happy I Love You GIF by joeyahlbum.gif","happy sign language GIF by signtime.gif","happy sign language GIF.gif","hate that.gif","hate.gif","he.gif","her.gif","holiday.gif","home.gif","hope.gif",
      "how.gif","how many.gif","hungry.gif","i want.gif","i gif.gif","in    out.gif","introduce sign language GIF.gif","it.gif","kids or kid both variation.gif","kind.gif","later.gif",
      "lie.gif","like.gif","long.gif","mad.gif","Marry Sign Language GIF.gif","me.gif","mean.gif","meet.gif","mine.gif","monkey.gif","more.gif","mother.gif",
      "my.gif","nervous.gif","none.gif","not.gif","now.gif","pain.gif","parents.gif","sad sign language GIF.gif","see watch.gif","see you.gif","seriously.gif","shes polite.gif",
      "shy.gif","sick of.gif","sick sign language GIF.gif","Sign Language Change GIF.gif","sign language cry GIF.gif","sign language love GIF.gif","Sign Language Month GIF.gif","sign language name GIF.gif",
      "sign language numbers GIF.gif","Sign Language Play GIF.gif","Sign Language Put GIF.gif","Sign Language School GIF.gif","Sign Language Sgsl GIF.gif","Sign Language Stand GIF.gif",
      "Sign Language Time GIF.gif","Sign Language Wait GIF.gif","Sign Language Walk GIF.gif","Sign Language Week GIF.gif","sign language what GIF.gif","Sign Language Year GIF.gif",
      "Sign Language Yes GIF by @InvestInAccess.gif","sign no GIF by signtime.gif","sign please GIF by signtime.gif","sign yes GIF by signtime.gif","sister.gif","somebody.gif","something.gif",
      "sorry sign language GIF by signtime.gif","spelling or alphabet.gif","Stay Home Sign Language GIF.gif","sucess.gif","super.gif","thank u.gif","their.gif","toilet.gif","us.gif","water.gif",
      "we.gif","welcome.gif","when.gif","where.gif","which.gif","who.gif","wife.gif","wonderful.gif","you.gif","your.gif"
    ];
    const uniq = (arr) => [...new Set(arr.map(v => (v || "").trim()).filter(Boolean))];
    const fileToKey = (name) => {
      const raw = name.toLowerCase()
        .replace(/\.gif$/i, "")
        .replace(/@investinaccess/g, " ")
        .replace(/\bgif by\b.*$/i, " ")
        .replace(/\bgif\b/gi, " ")
        .replace(/\bsign language\b/gi, " ")
        .replace(/\bsgsl\b/gi, " sign ")
        .replace(/'/g, "")
        .replace(/[^a-z0-9 ]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
      const fixed = {
        "americansignlanguage hello": "hello",
        "happy i love you": "i love you",
        "introduce": "introduce",
        "kids or kid both variation": "kid",
        "marry": "marry",
        "shes polite": "she is polite",
        "sign no": "no",
        "sign yes": "yes",
        "sign please": "please",
        "sucess": "success",
        "thank u": "thank you"
      };
      return fixed[raw] || raw;
    };
    const SIGN = {};
    SIGN_FILES.forEach((file) => {
      const key = fileToKey(file);
      if (!SIGN[key]) SIGN[key] = [];
      SIGN[key].push(file);
    });

    const SO_BASE = {
      "100":"boqol","1000":"kun","all":"dhammaan","allergic":"xasaasiyad","always":"mar walba","baby":"ilmo","bad":"xun","book":"buug","brother":"walaal lab",
      "brother sister":"walaal","busy":"mashquul","cannot":"ma karo","child":"cunug","come":"kaalay","continue":"sii wad","cool":"fiican","death":"geeri",
      "dont understand":"ma fahmin","each":"mid kasta","excuse me":"i raali ahow","family":"qoys","fast":"dhakhso","father":"aabe","favourite":"ugu jeclaan",
      "fine":"wanaagsan","free":"xor","friend":"saaxiib","give":"sii","good":"wanaag","gorilla":"gorilla","hate":"neceb","hate that":"taas waan necbahay","he":"isaga","hello":"salaan","her":"iyada",
      "happy":"faraxsan","holiday":"fasax","home":"guri","hope":"rajo","how":"sidee","how many":"imisa","hungry":"gaajaysan","i":"aniga","i love you":"waan ku jeclahay",
      "i want":"waan rabaa","in out":"gudaha bannaanka","introduce":"is baro","it":"wax","kid":"ilmo","kind":"naxariis","later":"danbe","lie":"been","like":"jecel",
      "long":"dheer","mad":"caraysan","marry":"guurso","mean":"xun","meet":"la kulan","me":"aniga","mine":"kayga","monkey":"daanyeer","more":"inbadan","mother":"hooyo",
      "my":"kayga","nervous":"walwal","none":"midna ma jiro","no":"maya","not":"maya","now":"hadda","numbers":"tirooyin","pain":"xanuun","parents":"waalidiin",
      "play":"ciyaar","please":"fadlan","put":"dhig","sad":"murugaysan","see watch":"arag daawo","see you":"ku arki doonaa","seriously":"runtii","she is polite":"iyada waa edeb",
      "shy":"xishood","sick":"xanuunsan","sick of":"ka daalay","sign":"calaamad","sorry":"waan ka xumahay","somebody":"qof","something":"wax","spelling or alphabet":"higgaad ama alifbeeto",
      "stand":"istaag","stay home":"guriga joog","success":"guul","super":"aad u fiican","sister":"walaal dhedig","thank you":"mahadsanid","their":"kooda","time":"waqti",
      "toilet":"musqul","us":"annaga","wait":"sug","walk":"socod","water":"biyo","we":"annaga","week":"usbuuc","welcome":"soo dhawoow","when":"goorma","where":"xagee",
      "which":"kee","who":"yaa","wife":"xaas","wonderful":"cajiib","year":"sano","yes":"haa","you":"adiga","your":"kaa","what":"maxay","love":"jacayl","school":"dugsi",
      "change":"beddel","cry":"ooy"
    };
    const SO = {};
    Object.keys(SIGN).forEach((key) => { SO[key] = SO_BASE[key] || key; });

    const EN_BASE_VARIANTS = {
      "all":["all","everyone","everybody","everything","all of it"],
      "allergic":["allergic","allergy","allergies","reacting","reaction"],
      "book":["book","books","notebook","textbook","that book"],
      "child":["child","children","kid","kids","little one"],
      "death":["death","dead","died","passed away"],
      "father":["father","dad","daddy","papa"],
      "hate":["hate","hated","hates","dislike","can't stand"],
      "hate that":["hate that","i hate that","dont like that","do not like that"],
      "he":["he","him","that man","that guy"],
      "hello":["hello","hi","hey","heyy","hiya","yo","greetings","good morning","good evening"],
      "her":["her","hers","that woman","that girl"],
      "how":["how","how do","how can","how is","in what way"],
      "i":["i","me"],
      "i love you":["i love you","i luv you","love you","luv u","ily","i really love you"],
      "i want":["i want","want this","want that","i need","i would like"],
      "it":["it","this thing","that thing"],
      "kid":["kid","kids","child","children"],
      "kind":["kind","kindness","be kind","nice person"],
      "lie":["lie","lying","lied","not true","false statement"],
      "like":["like","liked","likes","enjoy","prefer"],
      "mean":["mean","means","what do you mean","meaning"],
      "mad":["mad","angry","upset","furious"],
      "mine":["mine","this is mine","it is mine","belongs to me","my own","that is mine","my book","my stuff"],
      "mother":["mother","mom","mum","mama"],
      "my":["my","my own","for me"],
      "no":["no","nope","nah","negative","not really","never"],
      "none":["none","nothing","no one","nobody"],
      "pain":["pain","painful","it hurts","hurt","aching","ache"],
      "parents":["parents","my parents","mother and father","mom and dad"],
      "please":["please","pls","plz","please help","please now","kindly"],
      "seriously":["seriously","for real","really seriously"],
      "shy":["shy","timid","bashful"],
      "sick of":["sick of","tired of","fed up","done with this"],
      "somebody":["somebody","someone","person"],
      "something":["something","anything","a thing"],
      "sorry":["sorry","so sorry","my bad","apologies","forgive me","pardon me"],
      "thank you":["thank you","thanks","thank u","thx","many thanks","thanks a lot"],
      "their":["their","theirs","belongs to them"],
      "us":["us","we all","our group"],
      "what":["what","what is","what now","which thing","what do you mean","what happened"],
      "who":["who","who is","who are you","who is that","who now","who there"],
      "wife":["wife","my wife","spouse"],
      "yes":["yes","yep","yeah","yup","sure","affirmative"],
      "you":["you","u","yourself"]
    };
    const EXTRA_CORRELATIONS = {
      "death":["die","dies","dying","deceased"],
      "allergic":["allergen","sensitive","sensitivity"],
      "always":["forever","everytime","each time"],
      "bad":["awful","terrible","poor"],
      "book":["read","reading","novel"],
      "busy":["occupied","swamped"],
      "cannot":["cant","unable","impossible"],
      "come":["arrive","arriving","came"],
      "continue":["keep going","resume","carry on"],
      "cool":["awesome","nice","great"],
      "each":["every","each one"],
      "fast":["quick","quickly","rapid"],
      "fine":["okay","ok","alright"],
      "free":["available","unlocked"],
      "friend":["buddy","pal"],
      "give":["hand","hand over","provide"],
      "good":["great","excellent","nice"],
      "happy":["glad","joyful"],
      "hate":["detest","loathe"],
      "home":["house"],
      "hope":["wish"],
      "hungry":["starving"],
      "kind":["gentle","helpful"],
      "later":["after","afterwards"],
      "like":["enjoy","love this"],
      "mad":["angry","annoyed","furious"],
      "more":["extra","additional"],
      "nervous":["anxious","worried"],
      "none":["nothing","nobody","noone"],
      "pain":["hurt","hurting","ache","aching"],
      "sad":["unhappy","down"],
      "seriously":["really","fr"],
      "shy":["timid","bashful"],
      "sick":["ill","unwell"],
      "sick of":["fed up","done with"],
      "somebody":["someone","person"],
      "something":["anything","thing"],
      "toilet":["bathroom","restroom","washroom"],
      "water":["drink water","h2o"],
      "welcome":["gladly welcome"],
      "wonderful":["amazing","fantastic"],
      "yes":["yeah","yep","yup"],
      "no":["nah","nope"]
    };
    Object.entries(EXTRA_CORRELATIONS).forEach(([key, arr]) => {
      EN_BASE_VARIANTS[key] = uniq((EN_BASE_VARIANTS[key] || []).concat(arr));
    });
    const SO_BASE_VARIANTS = {
      "hello":["salaan","salaam","asc","asalamu alaikum","asalaamu calaykum","iska warran"],
      "i love you":["waan ku jeclahay","waan ku jclhy","waan kuclahay","waan ku jecelahay","waan ku jacelahay","waan ku jeclahay adiga"],
      "dont understand":["ma fahmin","maan fahmin","ma fahmaayo","ma garanayo","waan wareersanahay","si fiican uma fahmin"],
      "thank you":["mahadsanid","mahadsantahay","waad mahadsantahay","aad baad u mahadsantahay","mahadcelin","mahadsanidin"],
      "yes":["haa","haye","waayahay","waa sax","waad saxantahay","ok"],
      "no":["maya","maya maya","diidmo","ma aha","marnaba","ma doonayo"],
      "please":["fadlan","fadlan i caawi","fadlan hadda","si naxariis leh","iiga raalli noqo","fadlann"],
      "good":["wanaag","fiican","aad u fiican","wacan","ok","sax"],
      "sorry":["waan ka xumahay","raali ahow","iiga raali noqo","cafis","aad baan uga xumahay","waan ka xumahay runtii"],
      "mine":["kayga","aniga leh","kan waa kayga","waxaan leeyahay","ii gaar ah","taas waa tayda"],
      "my":["kayga","tayda","aniga leh"],
      "book":["buug","buuga","buugga"],
      "child":["cunug","caruur","ilmo"],
      "father":["aabe","abbaha"],
      "mother":["hooyo","hooyada"],
      "hate":["neceb","waan necbahay","aan jeclayn"],
      "hate that":["taas waan necbahay","taas ma jecli"],
      "lie":["been","been sheeg","run ma aha"],
      "mad":["caraysan","xanaaqsan"],
      "sick of":["ka daalay","waan ka daalay","waan ka caajisay"],
      "wife":["xaas","xaaskeyga"],
      "their":["kooda","iyaga leh"],
      "us":["annaga","innaga"],
      "you":["adiga","adigaa"],
      "what":["maxay","waa maxay","maxaa","maxaa jira","maxaad tiri","maxaa dhacay"],
      "love":["jacayl","waan ku jeclahay","jaceyl","jeceyl","jacayl badan","waan jecelahay"],
      "school":["dugsi","iskuul","dugsiga","iskuulka","dugsi tag","dugsiga ayaan joogaa"],
      "me":["aniga","aniga ah","iga","aniga i","anigaa","naftayda"],
      "who":["yaa","waa kuma","kuma","yaa adiga","yaa taas","yaa halkaas"],
      "how":["sidee","sidee bay","sidee tahay","sidee loo","qaabkee"]
    };
    const buildAliases = (key) => {
      const soWord = SO[key] || key;
      const enTemplates = key.includes(" ")
        ? [key]
        : [key, `my ${key}`, `the ${key}`, `${key} please`];
      const en = uniq((EN_BASE_VARIANTS[key] || []).concat(enTemplates));
      const so = uniq((SO_BASE_VARIANTS[key] || []).concat([soWord, `fadlan ${soWord}`, `${soWord} ayaan rabaa`, `${soWord} hadda`, `${soWord} ma jiraa`, `${soWord} iga caawi`]));
      return uniq(en.concat(so));
    };
    const ALIAS = {};
    Object.keys(SIGN).forEach((key) => { ALIAS[key] = buildAliases(key); });
    const TEXT = {
      en: {
        idle: "Idle",
        listening: "Listening...",
        processing: "Processing...",
        showing: "Showing",
        defaultTranscript: "Click the microphone and start speaking.",
        defaultPlaceholder: "Signs will appear here one by one.",
        noMap: "No mappable signs found for the input.",
        emptyInput: "Please speak or type a sentence first.",
        waitingInput: "Waiting for valid text input.",
        noSpeech: "No speech detected. Please try again.",
        unsupported: "Speech recognition not supported in this browser. Please use Google Chrome.",
        micDenied: "Microphone permission denied. Please allow mic access in your browser.",
        micDeniedHelp: "Microphone permission is required.",
        noMic: "No microphone was detected. Connect a mic and try again.",
        noMicHelp: "No microphone available.",
        speechErr: "Speech recognition error",
        speechErrHelp: "Could not process speech input.",
        micBlocked: "Microphone blocked",
        micMissing: "No microphone",
        error: "Error",
        micStartFail: "Could not start microphone. Please allow mic access and try again.",
        micStartFailHelp: "Microphone start failed."
      },
      so: {
        idle: "Sug",
        listening: "Dhageysanaya...",
        processing: "Habaynaya...",
        showing: "Muujinaya",
        defaultTranscript: "Riix makarafoonka kadib hadal.",
        defaultPlaceholder: "Calaamadaha ayaa halkan ku soo muuqanaya mid mid.",
        noMap: "Ma helin calaamad ku habboon qoraalka.",
        emptyInput: "Fadlan hadal ama qor jumlad marka hore.",
        waitingInput: "Waxaan sugayaa qoraal sax ah.",
        noSpeech: "Hadal lama maqal. Fadlan mar kale isku day.",
        unsupported: "Aqoonsiga codka browser-kan ma taageero. Fadlan isticmaal Chrome.",
        micDenied: "Ogolaanshaha makarafoonka waa la diiday. Fadlan ogolow makarafoonka.",
        micDeniedHelp: "Makarafoon ogolaansho ayaa loo baahan yahay.",
        noMic: "Makarafoon lama helin. Ku xidh makarafoon kadib isku day mar kale.",
        noMicHelp: "Makarafoon lama heli karo.",
        speechErr: "Khalad aqoonsiga codka",
        speechErrHelp: "Gelinta codka lama farsameyn karin.",
        micBlocked: "Makarafoon xiran",
        micMissing: "Makarafoon ma jiro",
        error: "Khalad",
        micStartFail: "Makarafoonka lama bilaabi karin. Fadlan ogolow makarafoonka kadibna isku day mar kale.",
        micStartFailHelp: "Bilowga makarafoonka wuu fashilmay."
      }
    };
    const UI = {
      en: {
        appTitle: "Speech to Sign",
        appSubtitle: "Speak and see it in sign language",
        ramadanTag: "Ramadan Kareem",
        recognizedTitle: "Recognized Text",
        signPlaybackTitle: "Sign Playback",
        themeLabel: "Theme",
        repeatTitle: "Repeat sign playback",
        outputLabel: "Output",
        fallbackLabel: "Fallback",
        gifs: "GIFs",
        text: "Text",
        smart: "Smart",
        alphabet: "Alphabet",
        manualLabel: "Type text to translate",
        inputPlaceholder: "Example: hello, i love you",
        translate: "Translate Text",
        clear: "Clear",
        reload: "Reload",
        madeBy: "Made By",
        langPrefix: "Lang",
        chooseLanguage: "Choose language",
        chooseTheme: "Choose visual theme",
        themeRamadanDawn: "Ramadan Dawn",
        themeMidnight: "Midnight",
        themeOasis: "Oasis",
        themeSunset: "Sunset",
        themeRoyal: "Royal",
        themeNeonGrid: "Neon Grid",
        themePaper: "Paper",
        themeMono: "Mono",
        themeForestNoir: "Forest Noir",
        themeCandyPop: "Candy Pop",
        startMicAria: "Start speech recognition",
        stopMicAria: "Stop speech recognition"
      },
      so: {
        appTitle: "Hadal ilaa Calaamad",
        appSubtitle: "Hadal oo ku arag luqadda calaamadaha",
        ramadanTag: "Ramadan Kariim",
        recognizedTitle: "Qoraalka La Aqoonsaday",
        signPlaybackTitle: "Muujinta Calaamadaha",
        themeLabel: "Muuqaal",
        repeatTitle: "Ku celi muujinta calaamadaha",
        outputLabel: "Soo Saarid",
        fallbackLabel: "Beddel",
        gifs: "GIFs",
        text: "Qoraal",
        smart: "Caqli",
        alphabet: "Alifbeeto",
        manualLabel: "Qor qoraal aad turjunto",
        inputPlaceholder: "Tusaale: hello, i love you",
        translate: "Turjun Qoraalka",
        clear: "Nadiifi",
        reload: "Dib u Cusbooneysii",
        madeBy: "Waxaa Sameeyay",
        langPrefix: "Luqad",
        chooseLanguage: "Dooro luqad",
        chooseTheme: "Dooro muuqaalka",
        themeRamadanDawn: "Waaberiga Ramadan",
        themeMidnight: "Saqda Dhexe",
        themeOasis: "Oasis",
        themeSunset: "Qorrax Dhac",
        themeRoyal: "Boqortooyo",
        themeNeonGrid: "Shabakadda Neon",
        themePaper: "Warqad",
        themeMono: "Hal Midab",
        themeForestNoir: "Madowga Kaynta",
        themeCandyPop: "Nacnac Pop",
        startMicAria: "Bilow aqoonsiga codka",
        stopMicAria: "Jooji aqoonsiga codka"
      }
    };
    const AUTO_I18N_CACHE_KEY = "auto-i18n-cache-v1";
    const autoI18n = { ui: {}, text: {} };
    try {
      const parsed = JSON.parse(localStorage.getItem(AUTO_I18N_CACHE_KEY) || "{}");
      if (parsed && typeof parsed === "object") {
        autoI18n.ui = parsed.ui && typeof parsed.ui === "object" ? parsed.ui : {};
        autoI18n.text = parsed.text && typeof parsed.text === "object" ? parsed.text : {};
      }
    } catch {}
    let langLoadRun = 0;

    const normalizeText = t => t.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/[.,!?;:"'()\-]/g," ").replace(/\s+/g," ").trim();
    const phraseMap = {}, singleWordMap = {}, aliasMap = {}, soAliasMap = {}, variantIndex = {};
    Object.entries(SIGN).forEach(([k,files]) => {
      const srcList = (Array.isArray(files) ? files : [files]).map((f) => encodeURI(f));
      phraseMap[k]={srcList,token:k};
      if (!k.includes(" ")) singleWordMap[k] = srcList;
    });
    Object.entries(ALIAS).forEach(([k,arr]) => arr.forEach(a => aliasMap[normalizeText(a)]=k));
    Object.entries(SO).forEach(([k,v]) => { soAliasMap[normalizeText(v)] = k; });
    const CLOSEST_WORD_MAP = {
      a: "", an: "", the: "", is: "", am: "", are: "", was: "", were: "", be: "", being: "", been: "",
      to: "", of: "", on: "", at: "", in: "", for: "", from: "", with: "", and: "", but: "", or: "",
      this: "", that: "", these: "", those: "",
      belongs: "mine", owned: "mine", ownership: "mine", myself: "me", gave: "give", given: "give", gives: "give",
      angry: "mad", anger: "mad", furious: "mad", upset: "mad",
      lied: "lie", lying: "lie", false: "lie", untrue: "lie",
      dislike: "hate", hated: "hate", hates: "hate",
      tired: "sick of", fed: "sick of",
      mom: "mother", mum: "mother", mommy: "mother", mama: "mother",
      dad: "father", daddy: "father", papa: "father",
      children: "child", kids: "kid", kiddo: "kid",
      hurts: "pain", hurting: "pain", painful: "pain", ache: "pain", aching: "pain",
      wants: "i want", want: "i want", wanted: "i want", needing: "i want", needs: "i want", need: "i want",
      wnat: "i want", waant: "i want", watn: "i want", wnt: "i want", wan: "i want",
      likes: "like", liked: "like", loving: "love",
      ours: "us", theirs: "their", hers: "her", his: "he",
      anybody: "somebody", anyone: "somebody", anything: "something", somebodys: "somebody",
      spouse: "wife", partner: "wife"
    };
    const SINGLE_KEYS = Object.keys(singleWordMap);
    const SINGLE_ALIAS_ENTRIES = Object.entries(aliasMap)
      .filter(([alias]) => !alias.includes(" "))
      .map(([alias, key]) => ({ alias, key }));
    const singular = (w) => {
      if (w.endsWith("ies") && w.length > 4) return `${w.slice(0, -3)}y`;
      if (w.endsWith("es") && w.length > 3) return w.slice(0, -2);
      if (w.endsWith("s") && w.length > 3) return w.slice(0, -1);
      return w;
    };
    const stem = (w) => {
      if (w.endsWith("ing") && w.length > 5) return w.slice(0, -3);
      if (w.endsWith("ed") && w.length > 4) return w.slice(0, -2);
      if (w.endsWith("ly") && w.length > 4) return w.slice(0, -2);
      return w;
    };
    const distance = (a, b) => {
      if (Math.abs(a.length - b.length) > 2) return 99;
      const dp = Array.from({length: a.length + 1}, () => Array(b.length + 1).fill(0));
      for (let i = 0; i <= a.length; i++) dp[i][0] = i;
      for (let j = 0; j <= b.length; j++) dp[0][j] = j;
      for (let i = 1; i <= a.length; i++) {
        for (let j = 1; j <= b.length; j++) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost
          );
        }
      }
      return dp[a.length][b.length];
    };
    const sharePrefix = (a, b) => {
      if (!a || !b) return false;
      if (a[0] !== b[0]) return false;
      if (Math.min(a.length, b.length) >= 4) return a.slice(0, 2) === b.slice(0, 2);
      return true;
    };
    const bestFuzzyKey = (word) => {
      const maxDist = word.length <= 5 ? 1 : 2;
      let bestKey = "";
      let bestDist = maxDist + 1;

      for (const key of SINGLE_KEYS) {
        if (!sharePrefix(word, key)) continue;
        const d = distance(word, key);
        if (d < bestDist) {
          bestDist = d;
          bestKey = key;
          if (d === 0) return bestKey;
        }
      }
      for (const { alias, key } of SINGLE_ALIAS_ENTRIES) {
        if (!sharePrefix(word, alias)) continue;
        const d = distance(word, alias);
        if (d < bestDist) {
          bestDist = d;
          bestKey = key;
          if (d === 0) return bestKey;
        }
      }
      return bestDist <= maxDist ? bestKey : "";
    };
    const resolveClosestToken = (word) => {
      const n = norm(word);
      if (!n) return "";
      if (singleWordMap[n]) return n;
      const alias = aliasMap[n];
      if (alias && (singleWordMap[alias] || phraseMap[alias])) return alias;
      const soAlias = soAliasMap[n];
      if (soAlias && (singleWordMap[soAlias] || phraseMap[soAlias])) return soAlias;
      const forms = uniq([n, singular(n), stem(n), singular(stem(n))]);
      for (const f of forms) {
        if (singleWordMap[f] || phraseMap[f]) return f;
        const mapped = CLOSEST_WORD_MAP[f];
        if (mapped && (singleWordMap[mapped] || phraseMap[mapped])) return mapped;
        if (mapped === "") return "";
      }
      // Avoid forcing very short words into unrelated signs (e.g. "how" -> "now").
      if (n.length <= 3) return "";
      return bestFuzzyKey(n);
    };

    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    let rec = null, listening=false, hadResult=false, manualStop=false, run=0, output="gif", fallback="smart", last="";
    const wait = ms => new Promise(r=>setTimeout(r,ms));
    const splash = document.getElementById("entrySplash");

    function setupSplash(){
      if(!splash) return;
      const holdMs = 2000;
      const fadeMs = 300;
      setTimeout(() => {
        splash.classList.add("hide");
        setTimeout(() => splash.remove(), fadeMs + 10);
      }, holdMs);
    }

    const setStatus = (kind,txt) => { el.status.className = `status ${kind}`.trim(); el.status.textContent = txt; };
    const norm = normalizeText;
    const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");
    const applyAliasMap = (input, map) => {
      let out = input;
      Object.keys(map).sort((a,b)=>b.length-a.length).forEach((key)=>{
        out = out.replace(new RegExp(`\\b${esc(key)}\\b`, "g"), map[key]);
      });
      return out;
    };
    const aliasNorm = t => {
      let n=norm(t).replace(/\bgoing to\b/g,"go").replace(/\bi am\b/g,"i");
      n = applyAliasMap(n, aliasMap);
      if (isSomali()) n = applyAliasMap(n, soAliasMap);
      return n;
    };
    const isSomali = () => (el.langSel?.value || "").toLowerCase().startsWith("so");
    const langBase = () => ((el.langSel?.value || "en-US").split("-")[0] || "en").toLowerCase();
    const isEnglish = () => langBase() === "en";
    const getTextMap = () => {
      if (isSomali()) return TEXT.so;
      const base = langBase();
      return autoI18n.text[base] || TEXT.en;
    };
    const getUiMap = () => {
      if (isSomali()) return UI.so;
      const base = langBase();
      return autoI18n.ui[base] || UI.en;
    };
    const t = (key) => getTextMap()[key] || TEXT.en[key] || key;
    const uiText = (key) => getUiMap()[key] || UI.en[key] || key;
    let activeMode = "speech-to-sign";
    let handsTracker = null;
    let cam = null;
    let camRunning = false;
    let builtWord = "";
    const STABLE_GESTURE_FRAMES = 10;
    const GESTURE_RELEASE_FRAMES = 5;
    const GESTURE_COOLDOWN_MS = 1400;
    const makeHandState = () => ({
      candidate: "",
      stableFrames: 0,
      releaseFrames: 0,
      lastEmitTs: 0,
      lastToken: "",
      tipHistory: { thumb: [], index: [], pinky: [] }
    });
    const handStates = { Left: makeHandState(), Right: makeHandState(), Both: makeHandState() };
    const resetHandState = (key) => {
      handStates[key] = makeHandState();
    };
    const pointDistance = (a, b) => Math.hypot((a.x || 0) - (b.x || 0), (a.y || 0) - (b.y || 0));
    const clampHistory = (arr, max = 14) => {
      while (arr.length > max) arr.shift();
    };
    const palmScale = (landmarks) => Math.max(pointDistance(landmarks[0], landmarks[9]), 0.045);
    const fingerSpread = (landmarks, aTip, bTip) => pointDistance(landmarks[aTip], landmarks[bTip]) / palmScale(landmarks);
    const isFingerUp = (landmarks, tip, pip, mcp) => {
      const t = landmarks[tip], p = landmarks[pip], m = landmarks[mcp];
      return !!(t && p && m) && t.y < p.y && p.y < m.y;
    };
    const isFingerCurled = (landmarks, tip, pip) => {
      const t = landmarks[tip], p = landmarks[pip];
      return !!(t && p) && t.y > p.y;
    };
    const isThumbOpen = (landmarks, handedness) => {
      const tip = landmarks[4], mcp = landmarks[2], idxMcp = landmarks[5];
      if (!tip || !mcp || !idxMcp) return false;
      const dir = handedness === "Left" ? 1 : -1;
      return (tip.x - mcp.x) * dir > 0.02 && pointDistance(tip, idxMcp) > palmScale(landmarks) * 0.58;
    };
    const isThumbClosed = (landmarks) => {
      const tip = landmarks[4], idxMcp = landmarks[5], pinkyMcp = landmarks[17];
      if (!tip || !idxMcp || !pinkyMcp) return false;
      return tip.x > Math.min(idxMcp.x, pinkyMcp.x) && tip.x < Math.max(idxMcp.x, pinkyMcp.x);
    };
    const isTouching = (landmarks, a, b, scaleFactor = 0.33) => pointDistance(landmarks[a], landmarks[b]) < palmScale(landmarks) * scaleFactor;
    const isFingerTogether = (landmarks, aTip, bTip, maxSpread = 0.24) => fingerSpread(landmarks, aTip, bTip) <= maxSpread;
    const isFingerWide = (landmarks, aTip, bTip, minSpread = 0.4) => fingerSpread(landmarks, aTip, bTip) >= minSpread;
    const featureState = (landmarks, handedness) => {
      const thumbOpen = isThumbOpen(landmarks, handedness);
      const thumbClosed = isThumbClosed(landmarks);
      const indexUp = isFingerUp(landmarks, 8, 6, 5);
      const middleUp = isFingerUp(landmarks, 12, 10, 9);
      const ringUp = isFingerUp(landmarks, 16, 14, 13);
      const pinkyUp = isFingerUp(landmarks, 20, 18, 17);
      const indexCurled = isFingerCurled(landmarks, 8, 6);
      const middleCurled = isFingerCurled(landmarks, 12, 10);
      const ringCurled = isFingerCurled(landmarks, 16, 14);
      const pinkyCurled = isFingerCurled(landmarks, 20, 18);
      const idxThumbTouch = isTouching(landmarks, 4, 8);
      const midThumbTouch = isTouching(landmarks, 4, 12);
      const ringThumbTouch = isTouching(landmarks, 4, 16);
      const pinkyThumbTouch = isTouching(landmarks, 4, 20);
      const spreadIM = pointDistance(landmarks[8], landmarks[12]) / palmScale(landmarks);
      const spreadMR = pointDistance(landmarks[12], landmarks[16]) / palmScale(landmarks);
      const spreadRP = pointDistance(landmarks[16], landmarks[20]) / palmScale(landmarks);
      const indexHook = indexCurled && landmarks[8].y < landmarks[6].y && landmarks[8].x > landmarks[6].x;
      const indexMiddleTogether = isFingerTogether(landmarks, 8, 12, 0.22);
      const indexMiddleWide = isFingerWide(landmarks, 8, 12, 0.45);
      const ringPinkyTogether = isFingerTogether(landmarks, 16, 20, 0.24);
      const allFourUp = indexUp && middleUp && ringUp && pinkyUp;
      const fistLike = !indexUp && !middleUp && !ringUp && !pinkyUp;
      const indexSideways = Math.abs(landmarks[8].x - landmarks[6].x) > Math.abs(landmarks[8].y - landmarks[6].y);
      const middleSideways = Math.abs(landmarks[12].x - landmarks[10].x) > Math.abs(landmarks[12].y - landmarks[10].y);
      const indexMiddleCrossed = indexUp && middleUp && pointDistance(landmarks[8], landmarks[12]) < pointDistance(landmarks[6], landmarks[10]) * 0.68;
      const thumbBetweenIndexMiddle = landmarks[4].x > Math.min(landmarks[8].x, landmarks[12].x) && landmarks[4].x < Math.max(landmarks[8].x, landmarks[12].x);
      return {
        thumbOpen, thumbClosed, indexUp, middleUp, ringUp, pinkyUp,
        indexCurled, middleCurled, ringCurled, pinkyCurled, idxThumbTouch, midThumbTouch, ringThumbTouch, pinkyThumbTouch,
        spreadIM, spreadMR, spreadRP, indexHook, indexMiddleTogether, indexMiddleWide, ringPinkyTogether, allFourUp, fistLike,
        indexSideways, middleSideways, indexMiddleCrossed, thumbBetweenIndexMiddle
      };
    };
    const classifyStaticASL = (f) => {
      if (f.allFourUp && (f.thumbOpen || !f.thumbClosed)) return "HELLO ";
      if (f.thumbOpen && !f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp) return "YES ";

      if (f.fistLike && f.thumbClosed) return "A";
      if (f.allFourUp && !f.thumbOpen && f.ringPinkyTogether) return "B";
      if (!f.thumbOpen && f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp && f.thumbBetweenIndexMiddle) return "D";
      if (f.fistLike && f.idxThumbTouch && f.midThumbTouch) return "E";
      if (f.idxThumbTouch && f.middleUp && f.ringUp && f.pinkyUp) return "F";
      if (f.indexSideways && !f.middleUp && !f.ringUp && !f.pinkyUp && f.thumbOpen) return "G";
      if (f.indexUp && f.middleUp && f.indexSideways && f.middleSideways && !f.ringUp && !f.pinkyUp) return "H";
      if (!f.thumbOpen && !f.indexUp && !f.middleUp && !f.ringUp && f.pinkyUp) return "I";
      if (f.indexUp && f.thumbOpen && !f.middleUp && !f.ringUp && !f.pinkyUp) return "L";
      if (f.fistLike && f.thumbBetweenIndexMiddle && !f.thumbOpen) return "T";
      if (!f.thumbOpen && f.indexUp && f.middleUp && !f.ringUp && !f.pinkyUp && f.indexMiddleTogether) return "U";
      if (!f.thumbOpen && f.indexUp && f.middleUp && !f.ringUp && !f.pinkyUp && f.indexMiddleWide) return "V";
      if (!f.thumbOpen && f.indexUp && f.middleUp && f.ringUp && !f.pinkyUp) return "W";
      if (f.indexHook && !f.middleUp && !f.ringUp && !f.pinkyUp) return "X";
      if (f.thumbOpen && !f.indexUp && !f.middleUp && !f.ringUp && f.pinkyUp) return "Y";
      if (f.indexMiddleCrossed) return "R";
      if (f.fistLike && !f.thumbClosed && !f.thumbOpen) return "S";
      if (f.idxThumbTouch && f.midThumbTouch && !f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp) return "O";
      if (f.thumbClosed && f.indexCurled && f.middleCurled && f.ringCurled && f.pinkyCurled) return "M";
      if (f.thumbClosed && f.indexCurled && f.middleCurled && !f.ringCurled && f.pinkyCurled) return "N";
      if (f.thumbOpen && f.indexUp && f.middleUp && !f.ringUp && !f.pinkyUp && !f.indexSideways) return "K";
      if (f.thumbOpen && f.indexUp && f.middleUp && !f.ringUp && !f.pinkyUp && f.indexSideways) return "P";
      if (f.thumbOpen && !f.middleUp && !f.ringUp && !f.pinkyUp && f.indexSideways && !f.indexUp) return "Q";
      if (f.idxThumbTouch && !f.middleUp && !f.ringUp && !f.pinkyUp) return "9";
      if (f.pinkyThumbTouch && f.indexUp && f.middleUp && f.ringUp) return "6";
      if (f.ringThumbTouch && f.indexUp && f.middleUp && f.pinkyUp) return "7";
      if (f.midThumbTouch && f.indexUp && f.ringUp && f.pinkyUp) return "8";
      if (f.idxThumbTouch && f.midThumbTouch && f.ringThumbTouch && f.pinkyThumbTouch) return "0";
      if (f.allFourUp && !f.thumbOpen) return "4";
      if (f.allFourUp && f.thumbOpen) return "5";
      if (!f.thumbOpen && f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp) return "1";
      if (!f.thumbOpen && f.indexUp && f.middleUp && !f.ringUp && !f.pinkyUp) return "2";
      if (f.thumbOpen && f.indexUp && f.middleUp && !f.ringUp && !f.pinkyUp) return "3";
      return "";
    };
    const detectMotionASL = (f, handKey) => {
      const history = handStates[handKey]?.tipHistory || { thumb: [], index: [], pinky: [] };
      if (history.pinky.length >= 8 && !f.thumbOpen && !f.indexUp && !f.middleUp && !f.ringUp && f.pinkyUp) {
        const first = history.pinky[0];
        const last = history.pinky[history.pinky.length - 1];
        if (first && last && (last.x - first.x > 0.06) && (last.y - first.y > 0.05)) return "J";
      }
      if (history.index.length >= 10 && f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp) {
        let dirChanges = 0;
        let prevDir = 0;
        for (let i = 1; i < history.index.length; i++) {
          const dx = history.index[i].x - history.index[i - 1].x;
          const dir = dx > 0.008 ? 1 : dx < -0.008 ? -1 : 0;
          if (dir && prevDir && dir !== prevDir) dirChanges += 1;
          if (dir) prevDir = dir;
        }
        if (dirChanges >= 2) return "Z";
      }
      if (history.thumb && history.thumb.length >= 10 && f.thumbOpen && !f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp) {
        const span = Math.max(...history.thumb.map((p) => p.x)) - Math.min(...history.thumb.map((p) => p.x));
        if (span > 0.08) return "10";
      }
      return "";
    };
    const classifyGesture = (landmarks, handedness, handKey) => {
      const f = featureState(landmarks, handedness);
      const motion = detectMotionASL(f, handKey);
      if (motion) return motion;
      return classifyStaticASL(f);
    };
    const classifyTwoHandGesture = (leftLandmarks, rightLandmarks) => {
      const leftF = featureState(leftLandmarks, "Left");
      const rightF = featureState(rightLandmarks, "Right");
      const leftPalm = leftF.indexUp && leftF.middleUp && leftF.ringUp && leftF.pinkyUp;
      const rightPalm = rightF.indexUp && rightF.middleUp && rightF.ringUp && rightF.pinkyUp;
      const leftThumbOnly = leftF.thumbOpen && !leftF.indexUp && !leftF.middleUp && !leftF.ringUp && !leftF.pinkyUp;
      const rightThumbOnly = rightF.thumbOpen && !rightF.indexUp && !rightF.middleUp && !rightF.ringUp && !rightF.pinkyUp;
      const leftV = !leftF.thumbOpen && leftF.indexUp && leftF.middleUp && !leftF.ringUp && !leftF.pinkyUp;
      const rightV = !rightF.thumbOpen && rightF.indexUp && rightF.middleUp && !rightF.ringUp && !rightF.pinkyUp;
      const leftFist = !leftF.indexUp && !leftF.middleUp && !leftF.ringUp && !leftF.pinkyUp;
      const rightFist = !rightF.indexUp && !rightF.middleUp && !rightF.ringUp && !rightF.pinkyUp;
      if (leftPalm && rightPalm) return "WELCOME ";
      if (leftThumbOnly && rightThumbOnly) return "EXCELLENT ";
      if (leftV && rightV) return "PEACE ";
      if (leftFist && rightFist) return "BOOK ";
      return "";
    };
    const setGestureStatus = (kind, txt) => {
      if (!el.gestureStatus) return;
      el.gestureStatus.className = `status ${kind}`.trim();
      el.gestureStatus.textContent = txt;
    };
    const updateGestureWordUi = () => {
      if (el.gestureWord) el.gestureWord.textContent = builtWord || "No gestures detected yet.";
    };
    const appendGestureToken = (token) => {
      if (!token) return;
      builtWord += token;
      builtWord = builtWord.replace(/\s+/g, " ").trimStart();
      updateGestureWordUi();
    };
    const clearGestureBuilder = () => {
      builtWord = "";
      resetHandState("Left");
      resetHandState("Right");
      resetHandState("Both");
      updateGestureWordUi();
    };
    const speakGestureBuilder = () => {
      const text = builtWord.trim();
      if (!text || !("speechSynthesis" in window)) return;
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = el.langSel?.value || "en-US";
      window.speechSynthesis.speak(utter);
    };
    const processGestureCandidate = (token, handKey) => {
      const state = handStates[handKey] || (handStates[handKey] = makeHandState());
      if (!token) {
        state.candidate = "";
        state.stableFrames = 0;
        state.releaseFrames += 1;
        if (state.releaseFrames >= GESTURE_RELEASE_FRAMES) state.lastToken = "";
        return "";
      }
      state.releaseFrames = 0;
      if (token === state.candidate) state.stableFrames += 1;
      else {
        state.candidate = token;
        state.stableFrames = 1;
      }
      const now = Date.now();
      if (
        state.stableFrames >= STABLE_GESTURE_FRAMES &&
        now - state.lastEmitTs > GESTURE_COOLDOWN_MS &&
        token !== state.lastToken
      ) {
        appendGestureToken(token);
        state.lastToken = token;
        state.lastEmitTs = now;
        return token.trim();
      }
      return "";
    };
    const stopHandCamera = () => {
      if (cam) {
        try { cam.stop(); } catch {}
        cam = null;
      }
      const stream = el.cameraFeed?.srcObject;
      if (stream && typeof stream.getTracks === "function") stream.getTracks().forEach((track) => track.stop());
      if (el.cameraFeed) el.cameraFeed.srcObject = null;
      if (el.cameraOverlay) {
        const ctx = el.cameraOverlay.getContext("2d");
        if (ctx) ctx.clearRect(0, 0, el.cameraOverlay.width || 0, el.cameraOverlay.height || 0);
      }
      camRunning = false;
      resetHandState("Left");
      resetHandState("Right");
      resetHandState("Both");
      if (el.startCamBtn) el.startCamBtn.textContent = "Start Camera";
      setGestureStatus("", "Camera is off.");
    };
    const handleHandResults = (results) => {
      if (!el.cameraOverlay || !el.cameraFeed) return;
      const canvas = el.cameraOverlay;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const w = el.cameraFeed.videoWidth || 960;
      const h = el.cameraFeed.videoHeight || 540;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (results.image) ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
      const handLandmarks = results.multiHandLandmarks || [];
      const handLabelsSeen = new Set();
      const detectedTokens = [];
      const hands = [];
      if (handLandmarks.length) {
        for (let i = 0; i < handLandmarks.length; i++) {
          const landmarks = handLandmarks[i];
          const handedness = results.multiHandedness?.[i]?.label === "Left" ? "Left" : "Right";
          handLabelsSeen.add(handedness);
          hands.push({ landmarks, handedness });
          drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: "#55f0d3", lineWidth: 3 });
          drawLandmarks(ctx, landmarks, { color: "#0f7f88", fillColor: "#b8fff0", lineWidth: 1, radius: 3 });
        }

        let combinedActive = false;
        if (hands.length >= 2) {
          const leftHand = hands.find((h) => h.handedness === "Left") || hands[0];
          const rightHand = hands.find((h) => h.handedness === "Right") || hands[1];
          if (leftHand && rightHand && leftHand !== rightHand) {
            const combinedToken = classifyTwoHandGesture(leftHand.landmarks, rightHand.landmarks);
            if (combinedToken) {
              combinedActive = true;
              const bothEmitted = processGestureCandidate(combinedToken, "Both");
              if (bothEmitted) detectedTokens.push(`Both: ${bothEmitted}`);
            } else {
              processGestureCandidate("", "Both");
            }
          } else {
            processGestureCandidate("", "Both");
          }
        } else {
          processGestureCandidate("", "Both");
        }

        if (combinedActive) {
          processGestureCandidate("", "Left");
          processGestureCandidate("", "Right");
        } else {
          for (const { landmarks, handedness } of hands) {
            const state = handStates[handedness] || (handStates[handedness] = makeHandState());
            state.tipHistory.thumb.push({ x: landmarks[4].x, y: landmarks[4].y });
            state.tipHistory.index.push({ x: landmarks[8].x, y: landmarks[8].y });
            state.tipHistory.pinky.push({ x: landmarks[20].x, y: landmarks[20].y });
            clampHistory(state.tipHistory.thumb);
            clampHistory(state.tipHistory.index);
            clampHistory(state.tipHistory.pinky);
            const gesture = classifyGesture(landmarks, handedness, handedness);
            const emitted = processGestureCandidate(gesture, handedness);
            if (emitted) detectedTokens.push(`${handedness}: ${emitted}`);
          }
        }

        if (!handLabelsSeen.has("Left")) {
          resetHandState("Left");
          processGestureCandidate("", "Left");
        }
        if (!handLabelsSeen.has("Right")) {
          resetHandState("Right");
          processGestureCandidate("", "Right");
        }
        if (detectedTokens.length) setGestureStatus("processing", `Detected: ${detectedTokens.join(" | ")}`);
        else setGestureStatus("listening", "Tracking both hands. Hold sign steady.");
      } else {
        processGestureCandidate("", "Left");
        processGestureCandidate("", "Right");
        processGestureCandidate("", "Both");
        setGestureStatus("listening", "No hands detected. Show left or right hand.");
      }
      ctx.restore();
    };
    const startHandCamera = async () => {
      if (camRunning) {
        stopHandCamera();
        return;
      }
      if (!window.Hands || !window.Camera || !window.drawConnectors || !window.drawLandmarks) {
        setGestureStatus("error", "Camera tracking libraries are not loaded.");
        return;
      }
      try {
        if (!handsTracker) {
          handsTracker = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
          });
          handsTracker.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.6
          });
          handsTracker.onResults(handleHandResults);
        }
        cam = new Camera(el.cameraFeed, {
          onFrame: async () => {
            await handsTracker.send({ image: el.cameraFeed });
          },
          width: 960,
          height: 540
        });
        await cam.start();
        camRunning = true;
        if (el.startCamBtn) el.startCamBtn.textContent = "Stop Camera";
        setGestureStatus("listening", "Camera started. Show a gesture.");
      } catch {
        stopHandCamera();
        setGestureStatus("error", "Unable to start camera. Check permission.");
      }
    };
    const setMode = (mode) => {
      const next = mode === "sign-to-speech" ? "sign-to-speech" : "speech-to-sign";
      activeMode = next;
      if (el.speechToSignPane) el.speechToSignPane.hidden = next !== "speech-to-sign";
      if (el.signToSpeechPane) el.signToSpeechPane.hidden = next !== "sign-to-speech";
      if (el.navSpeechToSign) el.navSpeechToSign.classList.toggle("active", next === "speech-to-sign");
      if (el.navSignToSpeech) el.navSignToSpeech.classList.toggle("active", next === "sign-to-speech");
      if (next === "sign-to-speech" && rec && listening) {
        manualStop = true;
        rec.stop();
      }
      if (next === "speech-to-sign") stopHandCamera();
    };
    const THEME_UI_KEY = {
      "ramadan-dawn": "themeRamadanDawn",
      "midnight": "themeMidnight",
      "oasis": "themeOasis",
      "sunset": "themeSunset",
      "royal": "themeRoyal",
      "neon-grid": "themeNeonGrid",
      "paper": "themePaper",
      "mono": "themeMono",
      "forest-noir": "themeForestNoir",
      "candy-pop": "themeCandyPop"
    };
    const langMetaByCode = Object.fromEntries(LANGUAGES.map((l) => [l.code, l]));
    const localizeLanguageLabel = (code, uiLocale) => {
      const fallback = langMetaByCode[code]?.label || code;
      const [lang, region] = (code || "").split("-");
      if (!lang) return fallback;
      try {
        const langName = new Intl.DisplayNames([uiLocale || "en"], { type: "language" }).of(lang) || "";
        const regionName = region ? (new Intl.DisplayNames([uiLocale || "en"], { type: "region" }).of(region) || region) : "";
        if (langName && regionName) return `${langName} (${regionName})`;
        if (langName) return langName;
      } catch {}
      return fallback;
    };
    const refreshLanguageOptionLabels = () => {
      if (!el.langSel) return;
      const uiLocale = el.langSel.value || "en-US";
      [...el.langSel.options].forEach((opt) => {
        opt.textContent = localizeLanguageLabel(opt.value, uiLocale);
      });
    };
    const saveAutoI18n = () => {
      try { localStorage.setItem(AUTO_I18N_CACHE_KEY, JSON.stringify(autoI18n)); } catch {}
    };
    const translateValue = async (value, target) => {
      if (!value || !target || target === "en") return value;
      try {
        const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=${encodeURIComponent(target)}&dt=t&q=${encodeURIComponent(value)}`;
        const res = await fetch(url);
        if (!res.ok) return value;
        const data = await res.json();
        const out = (data?.[0] || []).map((part) => part?.[0] || "").join("").trim();
        return out || value;
      } catch {
        return value;
      }
    };
    const ensureAutoLang = async (target) => {
      if (!target || target === "en" || target === "so") return;
      if (autoI18n.ui[target] && autoI18n.text[target]) return;
      const [uiEntries, textEntries] = await Promise.all([
        Promise.all(Object.entries(UI.en).map(async ([k, v]) => [k, await translateValue(v, target)])),
        Promise.all(Object.entries(TEXT.en).map(async ([k, v]) => [k, await translateValue(v, target)]))
      ]);
      autoI18n.ui[target] = Object.fromEntries(uiEntries);
      autoI18n.text[target] = Object.fromEntries(textEntries);
      saveAutoI18n();
    };
    const applyUiLanguage = () => {
      document.documentElement.lang = (el.langSel?.value || "en-US").toLowerCase();
      const base = (el.langSel?.value || "en-US").split("-")[0].toLowerCase();
      document.documentElement.dir = ["ar","fa","he","ur"].includes(base) ? "rtl" : "ltr";
      if (el.appTitle) el.appTitle.textContent = uiText("appTitle");
      if (el.appSubtitle) el.appSubtitle.textContent = uiText("appSubtitle");
      if (el.ramadanTag) el.ramadanTag.textContent = uiText("ramadanTag");
      if (el.recognizedTitle) el.recognizedTitle.textContent = uiText("recognizedTitle");
      if (el.signPlaybackTitle) el.signPlaybackTitle.textContent = uiText("signPlaybackTitle");
      if (el.themeLabel) el.themeLabel.textContent = uiText("themeLabel");
      if (el.repeatBtn) {
        const rpt = uiText("repeatTitle");
        el.repeatBtn.title = rpt;
        el.repeatBtn.setAttribute("aria-label", rpt);
      }
      if (el.outputLabel) el.outputLabel.textContent = uiText("outputLabel");
      if (el.fallbackLabel) el.fallbackLabel.textContent = uiText("fallbackLabel");
      if (el.gifBtn) el.gifBtn.textContent = uiText("gifs");
      if (el.textBtn) el.textBtn.textContent = uiText("text");
      if (el.smartBtn) el.smartBtn.textContent = uiText("smart");
      if (el.alphaBtn) el.alphaBtn.textContent = uiText("alphabet");
      if (el.manualLabel) el.manualLabel.textContent = uiText("manualLabel");
      if (el.input) el.input.placeholder = uiText("inputPlaceholder");
      if (el.translate) el.translate.textContent = uiText("translate");
      if (el.clear) el.clear.textContent = uiText("clear");
      if (el.reload) el.reload.textContent = uiText("reload");
      if (el.madeByLabel) el.madeByLabel.textContent = uiText("madeBy");
      if (el.langSel) el.langSel.setAttribute("aria-label", uiText("chooseLanguage"));
      if (el.themeSel) el.themeSel.setAttribute("aria-label", uiText("chooseTheme"));
      if (el.themeSel) {
        [...el.themeSel.options].forEach((opt) => {
          const key = THEME_UI_KEY[opt.value];
          if (key) opt.textContent = uiText(key);
        });
      }
      refreshLanguageOptionLabels();
      if (el.mic) el.mic.setAttribute("aria-label", listening ? uiText("stopMicAria") : uiText("startMicAria"));
      setLangToggle();
    };
    const refreshLanguage = async () => {
      const runId = ++langLoadRun;
      applyUiLanguage();
      if (!isEnglish() && !isSomali()) {
        await ensureAutoLang(langBase());
        if (runId !== langLoadRun) return;
        applyUiLanguage();
      }
      if (!last) {
        el.trans.textContent = t("defaultTranscript");
        clearShow();
        setStatus("", t("idle"));
      } else {
        replay();
      }
    };
    const displayToken = (token) => (isSomali() && SO[token] ? SO[token] : token);
    const localizeText = (text) => {
      if (!isSomali() || !text) return text;
      let out = text;
      Object.keys(SO).sort((a,b)=>b.length-a.length).forEach((k)=>{
        out = out.replace(new RegExp(`\\b${esc(k)}\\b`, "g"), SO[k]);
      });
      return out;
    };

    const clearShow = (m=t("defaultPlaceholder")) => { el.show.innerHTML=`<p class="ph">${m}</p>`; el.tok.textContent=""; };
    const tokenCard = (token,title="Text") => { el.show.innerHTML=`<div class="tcard fade"><div><b>${title}</b><span>${token}</span></div></div>`; };
    const updateRepeatState = () => { if (el.repeatBtn) el.repeatBtn.disabled = !last; };
    const alphaSources = (c) => [`assets/alphabet/${c}.gif`, encodeURI("spelling or alphabet.gif")];

    const queueFor = (words, forceAlpha) => {
      const q=[]; const max=3;
      for(let i=0;i<words.length;i++){
        const w=words[i];
        if(forceAlpha){ [...w].filter(c=>c>="a"&&c<="z").forEach(c=>q.push({srcList:alphaSources(c),token:c,display:c})); continue; }
        // Force "i love you" to play as three separate signs instead of the single phrase GIF.
        if (
          i + 2 < words.length &&
          words[i] === "i" &&
          words[i + 1] === "love" &&
          words[i + 2] === "you" &&
          singleWordMap.i &&
          singleWordMap.love &&
          singleWordMap.you
        ) {
          q.push({srcList:singleWordMap.i,token:"i",display:displayToken("i")});
          q.push({srcList:singleWordMap.love,token:"love",display:displayToken("love")});
          q.push({srcList:singleWordMap.you,token:"you",display:displayToken("you")});
          i += 2;
          continue;
        }
        // Keep "i want" stable even when "want" is misspelled by typing or speech recognition.
        if (
          i + 1 < words.length &&
          w === "i" &&
          phraseMap["i want"] &&
          (
            words[i + 1] === "want" ||
            resolveClosestToken(words[i + 1]) === "i want" ||
            distance(words[i + 1], "want") <= 1
          )
        ) {
          q.push({...phraseMap["i want"], display:displayToken("i want")});
          i += 1;
          continue;
        }
        let found=null, size=0;
        for(let s=max;s>=2;s--){ if(i+s>words.length) continue; const p=words.slice(i,i+s).join(" "); if(phraseMap[p]){found=p;size=s;break;} }
        if(found){ q.push({...phraseMap[found], display:displayToken(found)}); i+=size-1; continue; }
        if(singleWordMap[w]) { q.push({srcList:singleWordMap[w],token:w,display:displayToken(w)}); continue; }
        const closest = resolveClosestToken(w);
        if (closest) {
          if (singleWordMap[closest]) q.push({srcList:singleWordMap[closest],token:closest,display:displayToken(closest)});
          else if (phraseMap[closest]) q.push({...phraseMap[closest], display:displayToken(closest)});
          continue;
        }
        // In smart mode, don't force alphabet GIF spelling for unknown words.
        // Keep unmatched token as text when text output is enabled.
        if (output === "text") q.push({src:"",token:w,display:w,fallback:true,title:isSomali()?"Qoraal":"Text"});
      }
      return q;
    };

    const pickSrc = (token, srcList) => {
      if(!srcList?.length) return "";
      const i = variantIndex[token] || 0;
      variantIndex[token] = (i + 1) % srcList.length;
      return srcList[i];
    };

    const render = item => new Promise(res=>{
      if(output==="text"){ tokenCard(item.display || item.token,isSomali()?"Qoraal":"Text"); res(); return; }
      const srcList = item.srcList || (item.src ? [item.src] : []);
      if(item.fallback || !srcList.length){ res(); return; }
      let done=false;
      const fin=()=>{if(done)return;done=true;res();};
      const start = variantIndex[item.token] || 0;
      const tryLoad = (offset) => {
        if (done) return;
        if (offset >= srcList.length) { fin(); return; }
        const idx = (start + offset) % srcList.length;
        const src = srcList[idx];
        const img = new Image();
        let settled = false;
        const settle = (ok) => {
          if (settled || done) return;
          settled = true;
          if (ok) {
            variantIndex[item.token] = (idx + 1) % srcList.length;
            el.show.innerHTML = "";
            el.show.appendChild(img);
            fin();
          } else {
            tryLoad(offset + 1);
          }
        };
        img.className = "fade";
        img.alt = `Sign animation for ${item.token}`;
        img.onload = () => settle(true);
        img.onerror = () => settle(false);
        img.src = src;
        // Large local GIFs can take longer to decode; short timeouts skip valid signs.
        setTimeout(() => settle(false), 8000);
      };
      tryLoad(0);
    });

    async function play(words, forceAlpha=false){
      run++; const id=run; const q=queueFor(words, forceAlpha);
      if(!q.length){ clearShow(t("noMap")); setStatus("",t("idle")); return; }
      for(const item of q){ if(id!==run) return; el.tok.textContent=`${t("showing")}: ${item.display || item.token}`; await render(item); await wait(1800); }
      if(id===run) setStatus("",t("idle"));
    }

    function translate(raw){
      const normalized = aliasNorm(raw);
      if(!normalized){ el.trans.textContent=t("emptyInput"); clearShow(t("waitingInput")); setStatus("",t("idle")); return; }
      const req=/\b(spell|alphabet|letter|letters)\b/g;
      const clean=normalized.replace(req," ").replace(/\s+/g," ").trim(); const final=clean || normalized;
      const words=final.split(" ").filter(Boolean);
      last=final; updateRepeatState(); el.trans.textContent=localizeText(final); setStatus("processing",t("processing")); play(words, fallback==="alphabet");
    }

    function reset(){ run++; el.trans.textContent=t("defaultTranscript"); el.input.value=""; clearShow(); el.mic.classList.remove("listening"); el.mic.setAttribute("aria-label",uiText("startMicAria")); listening=false; hadResult=false; manualStop=false; last=""; updateRepeatState(); setStatus("",t("idle")); }
    const replay=()=>{ if(last) translate(last); };
    const tog=(on,off)=>{on.classList.add("on");off.classList.remove("on");on.setAttribute("aria-pressed","true");off.setAttribute("aria-pressed","false");};
    const THEME_KEY = "theme-name";
    const THEME_NAMES = ["ramadan-dawn","midnight","oasis","sunset","royal","neon-grid","paper","mono","forest-noir","candy-pop"];
    const applyTheme = (name) => {
      const next = THEME_NAMES.includes(name) ? name : "ramadan-dawn";
      document.body.classList.remove(...THEME_NAMES.map((t) => `theme-${t}`));
      document.body.classList.add(`theme-${next}`);
      if (el.themeSel) el.themeSel.value = next;
      try { localStorage.setItem(THEME_KEY, next); } catch {}
    };
    const initTheme = () => {
      let saved = "";
      try { saved = localStorage.getItem(THEME_KEY) || ""; } catch {}
      // Migrate old light/dark setting if present.
      if (!saved) {
        let legacy = "";
        try { legacy = localStorage.getItem("theme-mode") || ""; } catch {}
        if (legacy === "dark") saved = "midnight";
      }
      applyTheme(saved || "ramadan-dawn");
    };
    const buildLanguageControls = () => {
      if (!el.langSel) return;
      el.langSel.innerHTML = "";
      (LANGUAGES || []).forEach(({ code, label }) => {
        const opt = document.createElement("option");
        opt.value = code;
        opt.textContent = label;
        el.langSel.appendChild(opt);
      });
      if (![...el.langSel.options].some((o) => o.value === el.langSel.value)) el.langSel.value = "en-US";
    };
    const setLangToggle = () => {
      if (!el.langToggleBtn || !el.langSel) return;
      const label = el.langSel.options[el.langSel.selectedIndex]?.text || "English (US)";
      el.langToggleBtn.textContent = `${uiText("langPrefix")}: ${label}`;
    };
    const toggleLangMenu = (open) => {
      if (!el.langMenu || !el.langToggleBtn) return;
      const shouldOpen = typeof open === "boolean" ? open : el.langMenu.hidden;
      el.langMenu.hidden = !shouldOpen;
      el.langToggleBtn.setAttribute("aria-expanded", shouldOpen ? "true" : "false");
    };

    function setupMic(){
      if(!SR){ el.trans.textContent=t("unsupported"); el.mic.disabled=true; setStatus("",t("idle")); return; }
      rec = new SR(); rec.lang=el.langSel?.value || "en-US"; rec.continuous=false; rec.interimResults=false; rec.maxAlternatives=1;
      rec.onstart=()=>{listening=true;hadResult=false;manualStop=false;el.mic.classList.add("listening");el.mic.setAttribute("aria-label",uiText("stopMicAria"));setStatus("listening",t("listening"));};
      rec.onresult=(e)=>{hadResult=true; const heard=(e.results?.[0]?.[0]?.transcript||"").trim(); if(!heard){el.trans.textContent=t("noSpeech"); clearShow(t("noSpeech")); setStatus("",t("idle")); return;} translate(heard);};
      rec.onend=()=>{listening=false;el.mic.classList.remove("listening");el.mic.setAttribute("aria-label",uiText("startMicAria")); if(!hadResult && !manualStop){el.trans.textContent=t("noSpeech"); clearShow(t("noSpeech")); setStatus("",t("idle"));} manualStop=false;};
      rec.onerror=(e)=>{const err=e.error||"unknown-error";
        if(err==="not-allowed"||err==="service-not-allowed"){el.trans.textContent=t("micDenied"); clearShow(t("micDeniedHelp")); setStatus("error",t("micBlocked"));}
        else if(err==="audio-capture"){el.trans.textContent=t("noMic"); clearShow(t("noMicHelp")); setStatus("error",t("micMissing"));}
        else if(err==="no-speech"){el.trans.textContent=t("noSpeech"); clearShow(t("noSpeech")); setStatus("",t("idle"));}
        else{el.trans.textContent=`${t("speechErr")}: ${err}`; clearShow(t("speechErrHelp")); setStatus("error",t("error"));}
        listening=false;hadResult=false;manualStop=false;el.mic.classList.remove("listening");el.mic.setAttribute("aria-label",uiText("startMicAria"));
      };
    }

    el.mic.addEventListener("click",()=>{ if(!rec) return; if(listening){manualStop=true;rec.stop();return;} try{rec.start();}catch{el.trans.textContent=t("micStartFail");clearShow(t("micStartFailHelp"));setStatus("",t("idle"));}});
    el.translate.addEventListener("click",()=>translate(el.input.value));
    el.input.addEventListener("keydown",e=>{if(e.key==="Enter"){e.preventDefault();translate(el.input.value);}});
    el.clear.addEventListener("click",()=>{ if(rec&&listening) rec.stop(); reset(); });
    el.reload?.addEventListener("click",()=>{ window.location.reload(); });
    el.gifBtn.addEventListener("click",()=>{output="gif";tog(el.gifBtn,el.textBtn);replay();});
    el.textBtn.addEventListener("click",()=>{output="text";tog(el.textBtn,el.gifBtn);replay();});
    el.smartBtn.addEventListener("click",()=>{fallback="smart";tog(el.smartBtn,el.alphaBtn);replay();});
    el.alphaBtn.addEventListener("click",()=>{fallback="alphabet";tog(el.alphaBtn,el.smartBtn);replay();});
    el.repeatBtn?.addEventListener("click",()=>{ replay(); });
    el.navSpeechToSign?.addEventListener("click",()=>{ setMode("speech-to-sign"); });
    el.navSignToSpeech?.addEventListener("click",()=>{ setMode("sign-to-speech"); });
    el.startCamBtn?.addEventListener("click",()=>{ startHandCamera(); });
    el.speakGestureBtn?.addEventListener("click",()=>{ speakGestureBuilder(); });
    el.clearGestureBtn?.addEventListener("click",()=>{ clearGestureBuilder(); });
    el.langToggleBtn?.addEventListener("click",()=>{ toggleLangMenu(); });
    el.themeSel?.addEventListener("change",()=>{ applyTheme(el.themeSel.value); });
    el.langSel?.addEventListener("change",()=>{
      setLangToggle();
      refreshLanguage();
      toggleLangMenu(false);
      if(!rec) return;
      rec.lang = el.langSel.value;
      if(listening){
        manualStop = true;
        rec.stop();
        setTimeout(()=>{ try { rec.start(); } catch {} }, 120);
      }
    });
    document.addEventListener("click",(e)=>{
      if (!el.langMenu || !el.langToggleBtn) return;
      if (el.langMenu.hidden) return;
      const target = e.target;
      if (target instanceof Node && (el.langMenu.contains(target) || el.langToggleBtn.contains(target))) return;
      toggleLangMenu(false);
    });
    document.addEventListener("keydown",(e)=>{
      if (e.key === "Escape") toggleLangMenu(false);
    });

    buildLanguageControls();
    initTheme();
    setLangToggle();
    applyUiLanguage();
    el.trans.textContent = t("defaultTranscript");
    clearShow(); updateRepeatState(); setStatus("",t("idle")); setupSplash(); setupMic(); refreshLanguage();
    updateGestureWordUi();
    setMode("speech-to-sign");

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register(`./sw.js?v=${Date.now()}`).then((reg) => {
          reg.update().catch(() => {});
        }).catch(() => {});
      });
    }
  })();
  </script>
</body>
</html>
